var we=Object.defineProperty,be=Object.defineProperties;var Se=Object.getOwnPropertyDescriptors;var M=Object.getOwnPropertySymbols;var Ce=Object.prototype.hasOwnProperty,ke=Object.prototype.propertyIsEnumerable;var V=(b,$,w)=>$ in b?we(b,$,{enumerable:!0,configurable:!0,writable:!0,value:w}):b[$]=w,k=(b,$)=>{for(var w in $||($={}))Ce.call($,w)&&V(b,w,$[w]);if(M)for(var w of M($))ke.call($,w)&&V(b,w,$[w]);return b},E=(b,$)=>be(b,Se($));(function(){"use strict";const b="plugin-settings";async function $(){try{return await figma.clientStorage.getAsync(b)||{}}catch(t){return console.error("Failed to load settings:",t),{}}}async function w(t){try{return await figma.clientStorage.setAsync(b,t),!0}catch(e){return console.error("Failed to save settings:",e),!1}}class S extends Error{constructor(e,s,o){super(e),this.name="GitHubAPIError",this.status=s,this.documentation_url=o}}class O{constructor(e){this.baseUrl="https://api.github.com",this.config=e}getConfig(){return this.config}async request(e,s={}){var i,r;const o=e.startsWith("http")?e:`${this.baseUrl}${e}`,n=k({Authorization:`Bearer ${this.config.token}`,Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"},s.headers);try{const a=await fetch(o,E(k({},s),{headers:n}));if(a.status===429){const u=(i=a.headers)==null?void 0:i.get("X-RateLimit-Reset");throw new S(`Rate limit exceeded. Resets at ${u?new Date(parseInt(u)*1e3).toLocaleString():"unknown"}`,429)}const c=(r=a.headers)==null?void 0:r.get("content-type");let l;if(c!=null&&c.includes("application/json"))l=await a.json();else{const u=await a.text();try{l=JSON.parse(u)}catch(h){l=u}}if(!a.ok){const u=(l==null?void 0:l.message)||`HTTP ${a.status}: ${a.statusText}`;throw new S(u,a.status,l==null?void 0:l.documentation_url)}return l}catch(a){throw a instanceof S?a:new S(a instanceof Error?a.message:"Unknown error occurred")}}async getRepository(){return this.request(`/repos/${this.config.owner}/${this.config.repo}`)}async getBranch(e){const s=e||this.config.branch||"main";return this.request(`/repos/${this.config.owner}/${this.config.repo}/branches/${s}`)}async getUser(){return this.request("/user")}async testConnection(){var e,s;try{const o=await this.getUser(),n=await this.getRepository(),i=await this.getBranch(),r=((e=n.permissions)==null?void 0:e.push)||((s=n.permissions)==null?void 0:s.admin)||!1;return{success:!0,message:`Connected as ${o.login} to ${n.full_name}`,details:{user:o.login,repo:n.full_name,branch:i.name,hasWriteAccess:r}}}catch(o){if(o instanceof S){let n=o.message;return o.status===401?n="Invalid token. Please check your Personal Access Token.":o.status===404?n="Repository not found. Check owner/repo or token permissions.":o.status===403&&(n="Access forbidden. Your token may lack required permissions."),{success:!1,message:n}}return{success:!1,message:o instanceof Error?o.message:"Connection test failed"}}}async validateTokenPaths(e){const s=await Promise.all(e.map(async o=>{try{return await this.request(`/repos/${this.config.owner}/${this.config.repo}/contents/${o}?ref=${this.config.branch||"main"}`),{path:o,exists:!0}}catch(n){return n instanceof S&&n.status===404?{path:o,exists:!1,error:"File not found"}:{path:o,exists:!1,error:n instanceof Error?n.message:"Unknown error"}}}));return{valid:s.every(o=>o.exists),results:s}}}async function U(t,e,s){const o=t.getConfig(),n=s||o.branch||"main",i=await t.request(`/repos/${o.owner}/${o.repo}/contents/${e}?ref=${n}`);console.log(`ðŸ“„ Raw file response for ${e}:`,typeof i,i),console.log("ðŸ“„ Response keys:",Object.keys(i)),console.log("ðŸ“„ Has content field:","content"in i),console.log("ðŸ“„ File size:",i.size);const r=Array.isArray(i)?i[0]:i;if(r.size>1048576)throw new Error(`File ${e} is too large (${r.size} bytes). GitHub API doesn't return content for files over 1MB.`);if(!r.content){if(console.log("ðŸ“„ File metadata only, attempting download_url:",r.download_url),r.download_url){const c=await fetch(r.download_url);if(!c.ok)throw new Error(`Failed to fetch raw content for ${e}: ${c.status} ${c.statusText}`);return{content:await c.text(),sha:r.sha||"unknown",path:r.path||e}}throw new Error(`No content found for file ${e} and no download_url available`)}console.log(`ðŸ“„ Content type for ${e}:`,typeof r.content),console.log(`ðŸ“„ Content encoding for ${e}:`,r.encoding),console.log(`ðŸ“„ Content preview for ${e}:`,String(r.content).substring(0,100));const a=typeof r.content=="string"?r.content:String(r.content);try{let c=function(h){const d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";let m="",f=0;for(h=h.replace(/=+$/,"");f<h.length;){const g=d.indexOf(h.charAt(f++)),y=d.indexOf(h.charAt(f++)),v=d.indexOf(h.charAt(f++)),G=d.indexOf(h.charAt(f++)),T=g<<18|y<<12|v<<6|G;m+=String.fromCharCode(T>>16&255),v!==-1&&(m+=String.fromCharCode(T>>8&255)),G!==-1&&(m+=String.fromCharCode(T&255))}return m};const l=a.replace(/\n/g,"").replace(/\s/g,"");let u;return typeof atob!="undefined"?u=atob(l):u=c(l),console.log(`ðŸ“„ Successfully decoded ${e}, length: ${u.length}`),console.log(`ðŸ“„ Content preview for ${e}:`,u.substring(0,100)),{content:u,sha:r.sha||"unknown",path:r.path||e}}catch(c){throw console.error(`ðŸ“„ Failed to decode base64 content for ${e}:`,c),new Error(`Failed to decode content for ${e}: ${c instanceof Error?c.message:"Unknown error"}`)}}async function R(t,e,s){return await Promise.all(e.map(async n=>{try{return await U(t,n,s)}catch(i){return{content:"",sha:"",path:n,error:i instanceof Error?i.message:"Failed to fetch file"}}}))}function L(t){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";let s="",o=0;for(;o<t.length;){const n=t.charCodeAt(o++),i=o<t.length?t.charCodeAt(o++):0,r=o<t.length?t.charCodeAt(o++):0,a=n<<16|i<<8|r;s+=e.charAt(a>>18&63),s+=e.charAt(a>>12&63),s+=o-2<t.length?e.charAt(a>>6&63):"=",s+=o-1<t.length?e.charAt(a&63):"="}return s}async function x(t,e){const s=t.getConfig();let o;typeof btoa!="undefined"?o=btoa(e.content):o=L(e.content);const n={message:e.message,content:o,sha:e.sha,branch:e.branch};return t.request(`/repos/${s.owner}/${s.repo}/contents/${e.path}`,{method:"PUT",body:JSON.stringify(n)})}async function B(t,e){const s=t.getConfig();return t.request(`/repos/${s.owner}/${s.repo}/git/refs/heads/${e}`)}async function Y(t,e,s){const o=t.getConfig();return t.request(`/repos/${o.owner}/${o.repo}/git/refs`,{method:"POST",body:JSON.stringify({ref:`refs/heads/${e}`,sha:s})})}async function P(t,e,s){const o=t.getConfig(),n=s||o.branch||"main",i=await t.request(`/repos/${o.owner}/${o.repo}/contents/${e}?ref=${n}`),r=Array.isArray(i)?i:[i];return console.log(`ðŸ“‹ Raw GitHub API response for ${e}:`,r.length,"items"),r.length>0&&console.log("ðŸ“‹ Sample item structure:",r[0]),r.map(a=>({name:a.name||a.filename||"unknown",path:a.path||a.full_name||"unknown",type:a.type||"unknown",sha:a.sha||"unknown"}))}async function N(t,e,s){const o=[];console.log(`ðŸ” Searching for token files with patterns: ${e.join(", ")}`);for(const i of e)if(console.log(`ðŸ“‚ Processing pattern: ${i}`),i.includes("*"))if(i.includes("**")){const r=i.split("**")[0].replace(/\/$/,"");console.log(`ðŸ”„ Recursive search in: ${r||"root"}`);try{const a=await F(t,r||"",s);console.log(`ðŸ“‹ Found ${a.length} total files in ${r||"root"}`);const c=a.filter(l=>l.endsWith(".json"));console.log(`ðŸ“„ Found ${c.length} JSON files: ${c.join(", ")}`),o.push(...c)}catch(a){console.error(`âŒ Failed recursive search in ${r}:`,a)}}else{const r=i.split("*")[0].replace(/\/$/,"");console.log(`ðŸ“ Listing directory: ${r||"root"}`);try{const a=await P(t,r,s);console.log(`ðŸ“‹ Found ${a.length} items in ${r||"root"}:`,a.map(l=>`${l.name} (${l.type})`));const c=a.filter(l=>l.type==="file"&&l.name.endsWith(".json")).map(l=>l.path);console.log(`ðŸ“„ Filtered to ${c.length} JSON files: ${c.join(", ")}`),o.push(...c)}catch(a){console.error(`âŒ Failed to list directory ${r}:`,a)}}else console.log(`ðŸ“Œ Adding direct file path: ${i}`),o.push(i);const n=[...new Set(o)];return console.log(`âœ… Final result: ${n.length} unique files found: ${n.join(", ")}`),n}async function F(t,e,s,o=[]){try{const n=await P(t,e,s);for(const i of n)i.type==="file"?o.push(i.path):i.type==="dir"&&await F(t,i.path,s,o)}catch(n){console.warn(`Failed to list directory ${e}:`,n)}return o}async function D(){return(await figma.variables.getLocalVariableCollectionsAsync()).map(e=>({id:e.id,name:e.name,modes:e.modes,defaultModeId:e.defaultModeId,variableIds:e.variableIds}))}async function A(t){return(await figma.variables.getLocalVariableCollectionsAsync()).find(s=>s.name===t)||null}async function H(t){let e=await A(t);return e||(e=figma.variables.createVariableCollection(t),console.log(`Created variable collection: ${t}`)),e}async function J(t){try{const e=await A(t);return e?e.modes.map(s=>({modeId:s.modeId,name:s.name})):(console.log(`Collection "${t}" not found`),[])}catch(e){return console.error(`Failed to get modes for collection "${t}":`,e),[]}}function q(t,e){if(!e)return t.defaultModeId;const s=t.modes.find(o=>o.name===e);return s?s.modeId:(console.warn(`Mode "${e}" not found in collection "${t.name}", using default mode`),t.defaultModeId)}async function I(t){return(await Promise.all(t.variableIds.map(async s=>await figma.variables.getVariableByIdAsync(s)))).filter(s=>s!==null)}async function _(t,e){return(await I(t)).find(o=>o.name===e)||null}async function W(t,e,s,o,n){let i=await _(t,e);i?i.resolvedType!==s&&(console.warn(`Variable ${e} type mismatch: expected ${s}, found ${i.resolvedType}`),i.id,i.remove(),i=figma.variables.createVariable(e,t,s),console.log(`Recreated variable: ${e} with new type ${s}`)):(i=figma.variables.createVariable(e,t,s),console.log(`Created variable: ${e} (${s})`));const r=t.defaultModeId;return i.setValueForMode(r,o),n&&(i.description=n),i}async function z(t,e,s,o,n,i){let r=await _(t,e);r?r.resolvedType!==s&&(console.warn(`Variable ${e} type mismatch: expected ${s}, found ${r.resolvedType}`),r.id,r.remove(),r=figma.variables.createVariable(e,t,s),console.log(`Recreated variable: ${e} with new type ${s}`)):(r=figma.variables.createVariable(e,t,s),console.log(`Created variable: ${e} (${s})`));const a=q(t,n),c=n||"default";return r.setValueForMode(a,o),console.log(`Set variable ${e} in mode "${c}"`),i&&(r.description=i),r}function K(t){const e=t.trim();if(e.startsWith("#")){let o=e.slice(1);if(o.length===3&&(o=o.split("").map(n=>n+n).join("")),o.length===6||o.length===8){const n=parseInt(o.slice(0,2),16)/255,i=parseInt(o.slice(2,4),16)/255,r=parseInt(o.slice(4,6),16)/255,a=o.length===8?parseInt(o.slice(6,8),16)/255:1;return{r:n,g:i,b:r,a}}}const s=e.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+)\s*)?\)/);if(s){const o=parseInt(s[1])/255,n=parseInt(s[2])/255,i=parseInt(s[3])/255,r=s[4]?parseFloat(s[4]):1;return{r:o,g:n,b:i,a:r}}return null}function X(t){const e=t.trim(),s=e.match(/^([\d.]+)/);if(s)return parseFloat(s[1]);const o=parseFloat(e);return isNaN(o)?0:o}function Q(t){const e=Math.round(t.r*255).toString(16).padStart(2,"0"),s=Math.round(t.g*255).toString(16).padStart(2,"0"),o=Math.round(t.b*255).toString(16).padStart(2,"0");if(t.a<1){const n=Math.round(t.a*255).toString(16).padStart(2,"0");return`#${e}${s}${o}${n}`}return`#${e}${s}${o}`}function j(t,e=""){const s=[];for(const[o,n]of Object.entries(t)){const i=e?`${e}/${o}`:o;Z(n)?s.push({path:i,value:n.value,type:n.type,comment:n.comment}):s.push(...j(n,i))}return s}function Z(t){return t&&typeof t=="object"&&"value"in t}function ee(t,e){const s=t==null?void 0:t.toLowerCase();return s==="color"||s==="colorrgb"||s==="colorhex"||s==="colorrgba"?"COLOR":s==="dimension"||s==="size"||s==="sizing"||s==="spacing"||s==="fontsize"||s==="fontweight"||s==="lineheight"||s==="letterSpacing"||s==="opacity"||s==="number"?"FLOAT":s==="boolean"?"BOOLEAN":s==="string"||s==="fontfamily"||s==="fontstyle"||s==="text"?"STRING":typeof e=="boolean"?"BOOLEAN":typeof e=="number"?"FLOAT":typeof e=="string"?e.startsWith("#")||e.startsWith("rgb")||e.startsWith("hsl")?"COLOR":/^\d+(\.\d+)?(px|rem|em|pt|%)$/.test(e)?"FLOAT":"STRING":"STRING"}function te(t,e){if(e==="COLOR"){let s=t;if(typeof t=="object"&&t!==null&&"value"in t&&(s=t.value),typeof s=="string"){const o=K(s);if(!o)throw new Error(`Invalid color value: ${s}`);return o}throw new Error(`Color value must be a string, got ${typeof s} (original: ${typeof t})`)}if(e==="FLOAT"){if(typeof t=="number")return t;if(typeof t=="string")return X(t);throw new Error(`Float value must be a number or string, got ${typeof t}`)}if(e==="BOOLEAN"){if(typeof t=="boolean")return t;if(typeof t=="string")return t.toLowerCase()==="true";throw new Error(`Boolean value must be a boolean or string, got ${typeof t}`)}return e==="STRING"?String(t):null}function se(t){const e=t.split("/");if(e.length>0){const s=e[0];return s.charAt(0).toUpperCase()+s.slice(1)}return"Tokens"}function oe(t){const e=t.split("/");return e.length>1?e.slice(1).join("/"):e[0]}async function ne(t,e={}){const s={success:!0,collectionsCreated:0,variablesCreated:0,variablesUpdated:0,errors:[],warnings:[]};try{const o=j(t);if(o.length===0)return s.warnings.push("No tokens found to import"),s;console.log(`Found ${o.length} tokens to import`);const n=new Map;for(const i of o){const r=e.collectionName||se(i.path);n.has(r)||n.set(r,[]),n.get(r).push(i)}for(const[i,r]of n)try{const c=(await figma.variables.getLocalVariableCollectionsAsync()).find(d=>d.name===i),l=await H(i);c||s.collectionsCreated++;const u=await Promise.all(l.variableIds.map(async d=>await figma.variables.getVariableByIdAsync(d))),h=new Set(u.filter(d=>d!==null).map(d=>d.name));for(const d of r)try{const m=e.collectionName?d.path:oe(d.path),f=ee(d.type,d.value),g=te(d.value,f);if(g===null){s.warnings.push(`Skipped token ${d.path}: could not convert value`);continue}const y=h.has(m);e.targetMode?await z(l,m,f,g,e.targetMode,d.comment):await W(l,m,f,g,d.comment),y?s.variablesUpdated++:s.variablesCreated++}catch(m){s.errors.push(`Failed to process token ${d.path}: ${m instanceof Error?m.message:"Unknown error"}`)}}catch(a){s.errors.push(`Failed to process collection ${i}: ${a instanceof Error?a.message:"Unknown error"}`)}s.success=s.errors.length===0}catch(o){s.success=!1,s.errors.push(`Transform failed: ${o instanceof Error?o.message:"Unknown error"}`)}return s}function C(t,e){const s=e||t;if(typeof t=="string"){const o=t.match(/^\{(.+)\}$/);if(o){const n=o[1],i=n.split(".");let r=s;for(const a of i)if(r&&typeof r=="object"&&a in r)r=r[a];else return console.warn(`Token reference not found: ${n}`),t;return C(r,s)}return t}if(Array.isArray(t))return t.map(o=>C(o,s));if(typeof t=="object"&&t!==null){const o={};for(const[n,i]of Object.entries(t))o[n]=C(i,s);return o}return t}function re(t){try{let e=JSON.parse(t);if(!e||typeof e!="object")throw new Error("Invalid token file: expected JSON object");return e=C(e),e}catch(e){throw e instanceof SyntaxError?new Error(`Invalid JSON: ${e.message}`):e}}function ae(t){switch(t){case"COLOR":return"color";case"FLOAT":return"dimension";case"STRING":return"string";case"BOOLEAN":return"boolean";default:return"string"}}function ie(t,e){return e==="COLOR"&&typeof t=="object"&&"r"in t?Q(t):e==="FLOAT"&&typeof t=="number"||e==="BOOLEAN"&&typeof t=="boolean"||e==="STRING"&&typeof t=="string"?t:String(t)}function ce(t,e,s){const o=e.split("/");let n=t;for(let r=0;r<o.length-1;r++){const a=o[r];n[a]||(n[a]={}),n=n[a]}const i=o[o.length-1];n[i]=s}function le(t){return t.toLowerCase().replace(/\s+/g,"-")}async function ue(t={}){const e={success:!0,tokens:{},variablesProcessed:0,collectionsProcessed:0,errors:[],warnings:[]};try{const s=await D();if(s.length===0)return e.warnings.push("No variable collections found in this file"),e;for(const o of s)if(!(t.collectionsToInclude&&!t.collectionsToInclude.includes(o.name)))try{const n=await figma.variables.getVariableCollectionByIdAsync(o.id);if(!n){e.errors.push(`Collection ${o.name} not found`);continue}const i=await I(n);if(i.length===0){e.warnings.push(`Collection ${o.name} has no variables`);continue}const r=le(o.name),a={[r]:{}};for(const c of i)try{const l=n.defaultModeId,u=c.valuesByMode[l];if(u===void 0){e.warnings.push(`Variable ${c.name} has no value for default mode`);continue}const h=ae(c.resolvedType),m={value:ie(u,c.resolvedType),type:h};c.description&&(m.comment=c.description);const f=`${r}/${c.name}`;ce(a,f,m),e.variablesProcessed++}catch(l){e.errors.push(`Failed to process variable ${c.name}: ${l instanceof Error?l.message:"Unknown error"}`)}t.organizeByCollection?e.tokens[`${r}.json`]=a:(e.tokens["tokens.json"]||(e.tokens["tokens.json"]={}),Object.assign(e.tokens["tokens.json"],a)),e.collectionsProcessed++}catch(n){e.errors.push(`Failed to process collection ${o.name}: ${n instanceof Error?n.message:"Unknown error"}`)}e.success=e.errors.length===0}catch(s){e.success=!1,e.errors.push(`Transform failed: ${s instanceof Error?s.message:"Unknown error"}`)}return e}function fe(t){return JSON.stringify(t,null,2)}function de(t,e){const s={added:[],modified:[],removed:[]},o=(r,a="")=>{const c=new Map;for(const[l,u]of Object.entries(r)){const h=a?`${a}.${l}`:l;u&&typeof u=="object"&&"value"in u?c.set(h,u):u&&typeof u=="object"&&o(u,h).forEach((m,f)=>c.set(f,m))}return c},n=o(t),i=o(e);return i.forEach((r,a)=>{if(!n.has(a))s.added.push(a);else{const c=n.get(a);JSON.stringify(c)!==JSON.stringify(r)&&s.modified.push(a)}}),n.forEach((r,a)=>{i.has(a)||s.removed.push(a)}),s}async function ge(t,e){const s=t.getConfig();try{const n=(await B(t,e.baseBranch)).object.sha,r=`figma-tokens-${Date.now()}`;await Y(t,r,n),console.log(`Created branch: ${r}`);for(const c of e.files)try{let l="";try{l=(await t.request(`/repos/${s.owner}/${s.repo}/contents/${c.path}?ref=${e.baseBranch}`)).sha}catch(u){console.log(`File ${c.path} doesn't exist, will create new`)}await x(t,{path:c.path,content:c.content,message:`Update ${c.path} from Figma`,sha:l,branch:r}),console.log(`Updated ${c.path} on branch ${r}`)}catch(l){throw console.error(`Failed to update ${c.path}:`,l),new Error(`Failed to update ${c.path}: ${l instanceof Error?l.message:"Unknown error"}`)}const a=await t.request(`/repos/${s.owner}/${s.repo}/pulls`,{method:"POST",body:JSON.stringify({title:e.title,body:e.body,head:r,base:e.baseBranch})});return{success:!0,prUrl:a.html_url,prNumber:a.number,message:`Pull request created: ${a.html_url}`}}catch(o){return console.error("Failed to create PR:",o),{success:!1,message:`Failed to create pull request: ${o instanceof Error?o.message:"Unknown error"}`}}}function he(t){if(t.added.length+t.modified.length+t.removed.length===0)return"Update design tokens from Figma";const s=[];return t.added.length>0&&s.push(`${t.added.length} added`),t.modified.length>0&&s.push(`${t.modified.length} modified`),t.removed.length>0&&s.push(`${t.removed.length} removed`),`Update design tokens from Figma (${s.join(", ")})`}function pe(t,e){const s=[];return s.push("## Summary"),s.push(""),s.push("This PR updates design tokens exported from Figma variables."),s.push(""),s.push(`- **Collections processed:** ${e.collectionsProcessed}`),s.push(`- **Variables processed:** ${e.variablesProcessed}`),s.push(""),t.added.length>0||t.modified.length>0||t.removed.length>0?(s.push("## Changes"),s.push(""),t.added.length>0&&(s.push(`### âœ¨ Added (${t.added.length})`),s.push(""),t.added.slice(0,20).forEach(n=>{s.push(`- \`${n}\``)}),t.added.length>20&&s.push(`- ... and ${t.added.length-20} more`),s.push("")),t.modified.length>0&&(s.push(`### ðŸ”„ Modified (${t.modified.length})`),s.push(""),t.modified.slice(0,20).forEach(n=>{s.push(`- \`${n}\``)}),t.modified.length>20&&s.push(`- ... and ${t.modified.length-20} more`),s.push("")),t.removed.length>0&&(s.push(`### âŒ Removed (${t.removed.length})`),s.push(""),t.removed.slice(0,20).forEach(n=>{s.push(`- \`${n}\``)}),t.removed.length>20&&s.push(`- ... and ${t.removed.length-20} more`),s.push(""))):(s.push("## Changes"),s.push(""),s.push("No token changes detected (formatting or structure updates only)."),s.push("")),s.push("---"),s.push(""),s.push("ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)"),s.push(""),s.push("**Note:** Please review the changes carefully before merging."),s.join(`
`)}figma.showUI(__html__,{width:400,height:600,themeColors:!0}),figma.ui.onmessage=async t=>{console.log("Plugin received message:",t.type);try{switch(t.type){case"INIT":{const e=await $();p({type:"SETTINGS_LOADED",settings:e});break}case"SAVE_SETTINGS":{const e=await w(t.settings);p({type:"SETTINGS_SAVED",success:e});break}case"TEST_CONNECTION":{p({type:"SYNC_PROGRESS",message:"Testing connection..."});const e=await me(t.config);p({type:"CONNECTION_TESTED",success:e.success,message:e.message});break}case"PULL_FROM_GITHUB":{p({type:"SYNC_STARTED",direction:"pull"});try{const e=await ye(t.config);if(e.success){const s=await $(),o=E(k({},s),{lastSync:{timestamp:Date.now(),direction:"pull",status:"success",message:e.message}});await w(o)}p({type:"SYNC_COMPLETE",success:e.success,message:e.message})}catch(e){const s=e instanceof Error?e.message:"Pull failed";p({type:"SYNC_COMPLETE",success:!1,message:s})}break}case"PUSH_TO_GITHUB":{p({type:"SYNC_STARTED",direction:"push"});try{const e=await $e(t.config);if(e.success){const s=await $(),o=E(k({},s),{lastSync:{timestamp:Date.now(),direction:"push",status:"success",message:e.message}});await w(o)}p({type:"SYNC_COMPLETE",success:e.success,message:e.message,prUrl:e.prUrl})}catch(e){const s=e instanceof Error?e.message:"Push failed";p({type:"SYNC_COMPLETE",success:!1,message:s})}break}case"GET_COLLECTION_MODES":{try{const e=await J(t.collectionName);p({type:"COLLECTION_MODES",modes:e})}catch(e){console.error("Failed to get collection modes:",e),p({type:"COLLECTION_MODES",modes:[]})}break}default:console.warn("Unknown message type:",t.type)}}catch(e){console.error("Error handling message:",e);let s="Unknown error occurred";e instanceof S?(s=`GitHub API Error: ${e.message}`,e.status&&(s+=` (Status: ${e.status})`)):e instanceof Error&&(s=e.message),p({type:"ERROR",message:s})}};function p(t){figma.ui.postMessage(t)}async function me(t){try{const e=new O(t);p({type:"SYNC_PROGRESS",message:"Verifying credentials..."});const s=await e.testConnection();if(!s.success)return s;if(t.tokenPaths&&t.tokenPaths.length>0){p({type:"SYNC_PROGRESS",message:"Exploring repository structure..."});try{console.log("ðŸ” Attempting to list root directory...");const c=await e.request(`/repos/${t.owner}/${t.repo}/contents?ref=${t.branch||"main"}`);console.log("ðŸ—‚ï¸ Raw root response type:",typeof c,Array.isArray(c)),console.log("ðŸ—‚ï¸ Raw root response sample:",c[0]||c);const l=Array.isArray(c)?c:[c];console.log("ðŸ—‚ï¸ Repository root contents:",l.map(u=>`${u.name||u.filename||"unknown"} (${u.type||"unknown"})`)),p({type:"SYNC_PROGRESS",message:`Repository has ${l.length} items in root: ${l.slice(0,5).map(u=>u.name).join(", ")}${l.length>5?"...":""}`})}catch(c){console.error("Failed to list root directory:",c),p({type:"SYNC_PROGRESS",message:"Could not explore repository structure (continuing...)"})}p({type:"SYNC_PROGRESS",message:"Searching for token files..."});const n=await N(e,t.tokenPaths,t.branch);if(n.length===0)return{success:!1,message:`No token files found matching patterns: ${t.tokenPaths.join(", ")}`};const r=(await e.validateTokenPaths(n)).results.filter(c=>!c.exists);if(r.length>0)return{success:!1,message:`Missing token files: ${r.map(c=>c.path).join(", ")}`};const a=s.details;return{success:!0,message:`âœ“ Connected as ${a.user} to ${a.repo} (${a.branch})
âœ“ Found ${n.length} token file(s)
âœ“ Write access: ${a.hasWriteAccess?"Yes":"No"}`}}const o=s.details;return{success:!0,message:`âœ“ Connected as ${o.user} to ${o.repo} (${o.branch})
âœ“ Write access: ${o.hasWriteAccess?"Yes":"No"}`}}catch(e){return e instanceof S?{success:!1,message:e.message}:{success:!1,message:e instanceof Error?e.message:"Connection test failed"}}}async function ye(t){try{const e=new O(t);p({type:"SYNC_PROGRESS",message:"Finding token files..."});const s=await N(e,t.tokenPaths,t.branch);if(s.length===0)return{success:!1,message:`No token files found matching patterns: ${t.tokenPaths.join(", ")}`};p({type:"SYNC_PROGRESS",message:`Found ${s.length} token file(s)`}),p({type:"SYNC_PROGRESS",message:"Fetching token files..."});const o=await R(e,s,t.branch),n=o.filter(f=>f.error);if(n.length>0)return{success:!1,message:`Failed to fetch files:
${n.map(f=>`- ${f.path}: ${f.error}`).join(`
`)}`};p({type:"SYNC_PROGRESS",message:"Parsing token files..."});const i={},r=[];for(const f of o)if(!f.error)try{let g=f.content.trim();g=g.replace(/^\uFEFF/,""),g=g.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g,""),console.log(`ðŸ“„ Cleaned content for ${f.path} (length: ${g.length}):`,g.substring(0,200));const y=JSON.parse(g);if(!y||typeof y!="object")throw new Error("Invalid token file: expected JSON object");Object.assign(i,y),r.push({path:f.path,tokens:y}),console.log(`ðŸ“¦ Merged tokens from ${f.path}`)}catch(g){console.error(`Failed to parse ${f.path}:`,g)}p({type:"SYNC_PROGRESS",message:"Resolving token references..."});const a=C(i);console.log(`ðŸ”— Resolved ${Object.keys(i).length} top-level token groups`),p({type:"SYNC_PROGRESS",message:"Creating Figma variables..."});let c=0,l=0,u=0;const h=[],d=[];try{const f={collectionName:t.targetCollection||void 0,targetMode:t.targetMode||void 0};console.log("ðŸŽ¯ Transform options:",f);const g=await ne(a,f);c+=g.collectionsCreated,l+=g.variablesCreated,u+=g.variablesUpdated,h.push(...g.errors),d.push(...g.warnings),g.success||console.error("Failed to transform tokens:",g.errors)}catch(f){const g=`Failed to process tokens: ${f instanceof Error?f.message:"Unknown error"}`;h.push(g),console.error(g)}if(h.length>0)return{success:!1,message:`Sync completed with errors:
${h.slice(0,5).join(`
`)}${h.length>5?`
... and ${h.length-5} more errors`:""}`};const m=[`âœ“ Successfully imported ${o.length} token file(s)`,`âœ“ Collections: ${c} created`,`âœ“ Variables: ${l} created, ${u} updated`];return d.length>0&&m.push(`âš  Warnings: ${d.length}`),{success:!0,message:m.join(`
`)}}catch(e){return console.error("Pull failed:",e),e instanceof S?{success:!1,message:`GitHub API Error: ${e.message}`}:{success:!1,message:e instanceof Error?e.message:"Pull failed"}}}async function $e(t){try{const e=new O(t);p({type:"SYNC_PROGRESS",message:"Reading Figma variables..."});const s=await ue({organizeByCollection:!0});if(!s.success)return{success:!1,message:`Failed to read variables:
${s.errors.join(`
`)}`};if(s.variablesProcessed===0)return{success:!1,message:"No variables found in this file. Create some variables first!"};p({type:"SYNC_PROGRESS",message:`Read ${s.variablesProcessed} variables from ${s.collectionsProcessed} collection(s)`}),p({type:"SYNC_PROGRESS",message:"Preparing token files..."});const o=[];for(const[l,u]of Object.entries(s.tokens)){let h;if(t.tokenPaths.length===1&&!t.tokenPaths[0].includes("*"))h=t.tokenPaths[0];else{const m=t.tokenPaths[0]||"tokens/**/*.json";let f="tokens";if(m.includes("/")){const g=m.split("/"),y=g.filter(v=>!v.includes("*"));y.length>0?f=y.join("/"):f=g[0]==="."?"tokens":g[0]}h=`${f}/${l}`}console.log(`ðŸ“ Generated file path: ${h} for collection file: ${l}`);const d=fe(u);o.push({path:h,content:d})}p({type:"SYNC_PROGRESS",message:"Generating changelog..."});let n={added:[],modified:[],removed:[]};for(const l of o)try{const u=await R(e,[l.path],t.branch);if(u[0]&&!u[0].error){const h=re(u[0].content),d=JSON.parse(l.content),m=de(h,d);n.added.push(...m.added),n.modified.push(...m.modified),n.removed.push(...m.removed)}else{const h=JSON.parse(l.content),d=f=>{let g=0;for(const y of Object.values(f))y&&typeof y=="object"&&"value"in y?g++:y&&typeof y=="object"&&(g+=d(y));return g},m=d(h);n.added.push(`${l.path} (${m} tokens)`)}}catch(u){console.warn(`Could not fetch ${l.path} for comparison:`,u)}p({type:"SYNC_PROGRESS",message:"Creating Pull Request..."});const i=he(n),r=pe(n,{collectionsProcessed:s.collectionsProcessed,variablesProcessed:s.variablesProcessed}),a=await ge(e,{title:i,body:r,baseBranch:t.branch||"main",files:o});return a.success?{success:!0,message:["âœ“ Successfully created Pull Request",`âœ“ Files: ${o.length} updated`,`âœ“ Variables: ${s.variablesProcessed} exported`,`âœ“ PR: ${a.prUrl}`].join(`
`),prUrl:a.prUrl}:{success:!1,message:a.message}}catch(e){return console.error("Push failed:",e),e instanceof S?{success:!1,message:`GitHub API Error: ${e.message}`}:{success:!1,message:e instanceof Error?e.message:"Push failed"}}}})();
