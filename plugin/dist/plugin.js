var Le=Object.defineProperty,Ve=Object.defineProperties;var Ge=Object.getOwnPropertyDescriptors;var se=Object.getOwnPropertySymbols;var De=Object.prototype.hasOwnProperty,Je=Object.prototype.propertyIsEnumerable;var re=(S,w,k)=>w in S?Le(S,w,{enumerable:!0,configurable:!0,writable:!0,value:k}):S[w]=k,I=(S,w)=>{for(var k in w||(w={}))De.call(w,k)&&re(S,k,w[k]);if(se)for(var k of se(w))Je.call(w,k)&&re(S,k,w[k]);return S},B=(S,w)=>Ve(S,Ge(w));(function(){"use strict";const S="plugin-settings";async function w(){try{return await figma.clientStorage.getAsync(S)||{}}catch(o){return console.error("Failed to load settings:",o),{}}}async function k(o){try{return await figma.clientStorage.setAsync(S,o),!0}catch(e){return console.error("Failed to save settings:",e),!1}}class T extends Error{constructor(e,t,n){super(e),this.name="GitHubAPIError",this.status=t,this.documentation_url=n}}class L{constructor(e){this.baseUrl="https://api.github.com",this.config=e}getConfig(){return this.config}getAuthToken(){return this.config.oauthToken||this.config.token||""}async request(e,t={}){var r,a;const n=e.startsWith("http")?e:`${this.baseUrl}${e}`,s=this.getAuthToken();if(!s)throw new T("No authentication token provided");const i=I({Authorization:`Bearer ${s}`,Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"},t.headers);try{const l=await fetch(n,B(I({},t),{headers:i}));if(l.status===429){const g=(r=l.headers)==null?void 0:r.get("X-RateLimit-Reset");throw new T(`Rate limit exceeded. Resets at ${g?new Date(parseInt(g)*1e3).toLocaleString():"unknown"}`,429)}const d=(a=l.headers)==null?void 0:a.get("content-type");let u;if(d!=null&&d.includes("application/json"))u=await l.json();else{const g=await l.text();try{u=JSON.parse(g)}catch(f){u=g}}if(!l.ok){const g=(u==null?void 0:u.message)||`HTTP ${l.status}: ${l.statusText}`;throw new T(g,l.status,u==null?void 0:u.documentation_url)}return u}catch(l){throw l instanceof T?l:new T(l instanceof Error?l.message:"Unknown error occurred")}}async getRepository(){return this.request(`/repos/${this.config.owner}/${this.config.repo}`)}async getBranch(e){const t=e||this.config.branch||"main";return this.request(`/repos/${this.config.owner}/${this.config.repo}/branches/${t}`)}async getUser(){return this.request("/user")}async testConnection(){var e,t;try{const n=await this.getUser(),s=await this.getRepository(),i=await this.getBranch(),r=((e=s.permissions)==null?void 0:e.push)||((t=s.permissions)==null?void 0:t.admin)||!1;return{success:!0,message:`Connected as ${n.login} to ${s.full_name}`,details:{user:n.login,repo:s.full_name,branch:i.name,hasWriteAccess:r}}}catch(n){if(n instanceof T){let s=n.message;return n.status===401?s="Invalid token. Please check your Personal Access Token.":n.status===404?s="Repository not found. Check owner/repo or token permissions.":n.status===403&&(s="Access forbidden. Your token may lack required permissions."),{success:!1,message:s}}return{success:!1,message:n instanceof Error?n.message:"Connection test failed"}}}async validateTokenPaths(e){const t=await Promise.all(e.map(async n=>{try{return await this.request(`/repos/${this.config.owner}/${this.config.repo}/contents/${n}?ref=${this.config.branch||"main"}`),{path:n,exists:!0}}catch(s){return s instanceof T&&s.status===404?{path:n,exists:!1,error:"File not found"}:{path:n,exists:!1,error:s instanceof Error?s.message:"Unknown error"}}}));return{valid:t.every(n=>n.exists),results:t}}}const E=class E{static async startDeviceFlow(){const e=await fetch(E.DEVICE_CODE_URL,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify({client_id:E.CLIENT_ID,scope:"repo"})});if(!e.ok)throw new Error(`Failed to start device flow: ${e.statusText}`);return e.json()}static async pollForToken(e,t=5){return new Promise((n,s)=>{const i=async()=>{try{const a=await(await fetch(E.ACCESS_TOKEN_URL,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify({client_id:E.CLIENT_ID,device_code:e,grant_type:"urn:ietf:params:oauth:grant-type:device_code"})})).json();if("access_token"in a){n(a.access_token);return}if("error"in a)switch(a.error){case"authorization_pending":setTimeout(i,t*1e3);break;case"slow_down":setTimeout(i,(t+5)*1e3);break;case"expired_token":case"access_denied":s(new Error(a.error_description||a.error));break;default:s(new Error(`OAuth error: ${a.error}`))}}catch(r){s(r)}};i()})}};E.CLIENT_ID="your_github_app_client_id",E.DEVICE_CODE_URL="https://github.com/login/device/code",E.ACCESS_TOKEN_URL="https://github.com/login/oauth/access_token";let M=E;async function ae(o,e,t){const n=o.getConfig(),s=t||n.branch||"main",i=await o.request(`/repos/${n.owner}/${n.repo}/contents/${e}?ref=${s}`);console.log(`üìÑ Raw file response for ${e}:`,typeof i,i),console.log("üìÑ Response keys:",Object.keys(i)),console.log("üìÑ Has content field:","content"in i),console.log("üìÑ File size:",i.size);const r=Array.isArray(i)?i[0]:i;if(r.size>1048576)throw new Error(`File ${e} is too large (${r.size} bytes). GitHub API doesn't return content for files over 1MB.`);if(!r.content){if(console.log("üìÑ File metadata only, attempting download_url:",r.download_url),r.download_url){const l=await fetch(r.download_url);if(!l.ok)throw new Error(`Failed to fetch raw content for ${e}: ${l.status} ${l.statusText}`);return{content:await l.text(),sha:r.sha||"unknown",path:r.path||e}}throw new Error(`No content found for file ${e} and no download_url available`)}console.log(`üìÑ Content type for ${e}:`,typeof r.content),console.log(`üìÑ Content encoding for ${e}:`,r.encoding),console.log(`üìÑ Content preview for ${e}:`,String(r.content).substring(0,100));const a=typeof r.content=="string"?r.content:String(r.content);try{let l=function(c){const h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";let $="",m=0;for(c=c.replace(/=+$/,"");m<c.length;){const v=h.indexOf(c.charAt(m++)),N=h.indexOf(c.charAt(m++)),y=h.indexOf(c.charAt(m++)),O=h.indexOf(c.charAt(m++)),b=v<<18|N<<12|y<<6|O;$+=String.fromCharCode(b>>16&255),y!==-1&&($+=String.fromCharCode(b>>8&255)),O!==-1&&($+=String.fromCharCode(b&255))}return $};const d=a.replace(/\n/g,"").replace(/\s/g,"");let u;typeof atob!="undefined"?u=atob(d):u=l(d),u=u.replace(/\0/g,""),u=u.trim(),console.log(`üìÑ Successfully decoded ${e}, length: ${u.length}`),console.log(`üìÑ Content preview for ${e}:`,u.substring(0,100)),console.log(`üìÑ Content ending for ${e}:`,u.substring(Math.max(0,u.length-100)));const g=u.slice(-10),f=Array.from(g).map(c=>`${c}(${c.charCodeAt(0)})`).join(" ");console.log(`üìÑ Last 10 chars for ${e}:`,f);try{JSON.parse(u),console.log(`‚úÖ ${e} appears to be valid JSON`)}catch(c){if(console.error(`‚ùå ${e} JSON validation failed:`,c instanceof Error?c.message:c),c instanceof SyntaxError&&c.message.includes("line")){const h=u.split(`
`),$=c.message.match(/line (\d+)/);if($){const m=parseInt($[1]),v=Math.max(0,m-2),N=Math.min(h.length,m+1);console.error(`   Problem area around line ${m}:`);for(let y=v;y<N;y++){const O=y===m-1?">>> ":"    ";console.error(`   ${O}${y+1}: ${h[y]}`)}}}}return{content:u,sha:r.sha||"unknown",path:r.path||e}}catch(l){throw console.error(`üìÑ Failed to decode base64 content for ${e}:`,l),new Error(`Failed to decode content for ${e}: ${l instanceof Error?l.message:"Unknown error"}`)}}async function H(o,e,t){return await Promise.all(e.map(async s=>{try{return await ae(o,s,t)}catch(i){return{content:"",sha:"",path:s,error:i instanceof Error?i.message:"Failed to fetch file"}}}))}function ie(o){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";let t="",n=0;for(;n<o.length;){const s=o.charCodeAt(n++),i=n<o.length?o.charCodeAt(n++):0,r=n<o.length?o.charCodeAt(n++):0,a=s<<16|i<<8|r;t+=e.charAt(a>>18&63),t+=e.charAt(a>>12&63),t+=n-2<o.length?e.charAt(a>>6&63):"=",t+=n-1<o.length?e.charAt(a&63):"="}return t}async function le(o,e){const t=o.getConfig();let n;typeof btoa!="undefined"?n=btoa(e.content):n=ie(e.content);const s={message:e.message,content:n,sha:e.sha,branch:e.branch};return o.request(`/repos/${t.owner}/${t.repo}/contents/${e.path}`,{method:"PUT",body:JSON.stringify(s)})}async function ce(o,e){const t=o.getConfig();return o.request(`/repos/${t.owner}/${t.repo}/git/refs/heads/${e}`)}async function de(o,e,t){const n=o.getConfig();return o.request(`/repos/${n.owner}/${n.repo}/git/refs`,{method:"POST",body:JSON.stringify({ref:`refs/heads/${e}`,sha:t})})}async function q(o,e,t){const n=o.getConfig(),s=t||n.branch||"main",i=await o.request(`/repos/${n.owner}/${n.repo}/contents/${e}?ref=${s}`),r=Array.isArray(i)?i:[i];return console.log(`üìã Raw GitHub API response for ${e}:`,r.length,"items"),r.length>0&&console.log("üìã Sample item structure:",r[0]),r.map(a=>({name:a.name||a.filename||"unknown",path:a.path||a.full_name||"unknown",type:a.type||"unknown",sha:a.sha||"unknown"}))}async function z(o,e,t){const n=[];console.log(`üîç Searching for token files with patterns: ${e.join(", ")}`);for(const i of e)if(console.log(`üìÇ Processing pattern: ${i}`),i.includes("*"))if(i.includes("**")){const r=i.split("**")[0].replace(/\/$/,"");console.log(`üîÑ Recursive search in: ${r||"root"}`);try{const a=await W(o,r||"",t);console.log(`üìã Found ${a.length} total files in ${r||"root"}`);const l=a.filter(d=>d.endsWith(".json"));console.log(`üìÑ Found ${l.length} JSON files: ${l.join(", ")}`),n.push(...l)}catch(a){console.error(`‚ùå Failed recursive search in ${r}:`,a)}}else{const r=i.split("*")[0].replace(/\/$/,"");console.log(`üìÅ Listing directory: ${r||"root"}`);try{const a=await q(o,r,t);console.log(`üìã Found ${a.length} items in ${r||"root"}:`,a.map(d=>`${d.name} (${d.type})`));const l=a.filter(d=>d.type==="file"&&d.name.endsWith(".json")).map(d=>d.path);console.log(`üìÑ Filtered to ${l.length} JSON files: ${l.join(", ")}`),n.push(...l)}catch(a){console.error(`‚ùå Failed to list directory ${r}:`,a)}}else console.log(`üìå Adding direct file path: ${i}`),n.push(i);const s=[...new Set(n)];return console.log(`‚úÖ Final result: ${s.length} unique files found: ${s.join(", ")}`),s}async function W(o,e,t,n=[]){try{const s=await q(o,e,t);for(const i of s)i.type==="file"?n.push(i.path):i.type==="dir"&&await W(o,i.path,t,n)}catch(s){console.warn(`Failed to list directory ${e}:`,s)}return n}async function ue(){return(await figma.variables.getLocalVariableCollectionsAsync()).map(e=>({id:e.id,name:e.name,modes:e.modes,defaultModeId:e.defaultModeId,variableIds:e.variableIds}))}async function K(o){return(await figma.variables.getLocalVariableCollectionsAsync()).find(t=>t.name===o)||null}async function X(o){let e=await K(o);return e||(e=figma.variables.createVariableCollection(o),console.log(`Created variable collection: ${o}`)),e}async function fe(o){try{const e=await K(o);return e?e.modes.map(t=>({modeId:t.modeId,name:t.name})):(console.log(`Collection "${o}" not found`),[])}catch(e){return console.error(`Failed to get modes for collection "${o}":`,e),[]}}function ge(o,e){if(!e)return o.defaultModeId;const t=o.modes.find(n=>n.name===e);return t?t.modeId:(console.warn(`Mode "${e}" not found in collection "${o.name}", using default mode`),o.defaultModeId)}async function Q(o){return(await Promise.all(o.variableIds.map(async t=>await figma.variables.getVariableByIdAsync(t)))).filter(t=>t!==null)}async function Z(o,e){return(await Q(o)).find(n=>n.name===e)||null}async function he(o,e,t,n,s){let i=await Z(o,e);i?i.resolvedType!==t&&(console.warn(`Variable ${e} type mismatch: expected ${t}, found ${i.resolvedType}`),i.id,i.remove(),i=figma.variables.createVariable(e,o,t),console.log(`Recreated variable: ${e} with new type ${t}`)):(i=figma.variables.createVariable(e,o,t),console.log(`Created variable: ${e} (${t})`));const r=o.defaultModeId;return i.setValueForMode(r,n),s&&(i.description=s),i}async function V(o,e,t,n,s,i){let r=await Z(o,e);r?r.resolvedType!==t&&(console.warn(`Variable ${e} type mismatch: expected ${t}, found ${r.resolvedType}`),r.id,r.remove(),r=figma.variables.createVariable(e,o,t),console.log(`Recreated variable: ${e} with new type ${t}`)):(r=figma.variables.createVariable(e,o,t),console.log(`Created variable: ${e} (${t})`));const a=ge(o,s),l=s||"default";return r.setValueForMode(a,n),console.log(`Set variable ${e} in mode "${l}"`),i&&(r.description=i),r}function pe(o){const e=o.trim();if(e.startsWith("#")){let n=e.slice(1);if(n.length===3&&(n=n.split("").map(s=>s+s).join("")),n.length===6||n.length===8){const s=parseInt(n.slice(0,2),16)/255,i=parseInt(n.slice(2,4),16)/255,r=parseInt(n.slice(4,6),16)/255,a=n.length===8?parseInt(n.slice(6,8),16)/255:1;return{r:s,g:i,b:r,a}}}if(!e||typeof e!="string")return console.error("‚ö†Ô∏è  Invalid color value provided to parseColor:",e),null;const t=e.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+)\s*)?\)/);if(t){const n=parseInt(t[1])/255,s=parseInt(t[2])/255,i=parseInt(t[3])/255,r=t[4]?parseFloat(t[4]):1;return{r:n,g:s,b:i,a:r}}return null}function me(o){if(!o||typeof o!="string")return console.error("‚ö†Ô∏è  Invalid dimension string provided to parseDimension:",o),0;const e=o.trim(),t=e.match(/^([\d.]+)/);if(t)return parseFloat(t[1]);const n=parseFloat(e);return isNaN(n)?0:n}function be(o){const e=Math.round(o.r*255).toString(16).padStart(2,"0"),t=Math.round(o.g*255).toString(16).padStart(2,"0"),n=Math.round(o.b*255).toString(16).padStart(2,"0");if(o.a<1){const s=Math.round(o.a*255).toString(16).padStart(2,"0");return`#${e}${t}${n}${s}`}return`#${e}${t}${n}`}function $e(o,e){try{return JSON.parse(o)}catch(t){console.warn(`‚ö†Ô∏è  Initial JSON parse failed for ${e}, attempting recovery...`),console.warn(`   Error: ${t instanceof Error?t.message:"Unknown"}`);let n=o;try{n=n.replace(/,(\s*[}\]])/g,"$1"),console.log(`üîß Applied trailing comma fix for ${e}`);let s=JSON.parse(n);return console.log(`‚úÖ Fixed trailing commas in ${e}`),s}catch(s){}try{n=o.replace(/\/\/.*$/gm,""),n=n.replace(/,(\s*[}\]])/g,"$1"),console.log(`üîß Applied comment removal fix for ${e}`);let s=JSON.parse(n);return console.log(`‚úÖ Fixed comments in ${e}`),s}catch(s){}try{n=o.replace(/\/\*[\s\S]*?\*\//g,""),n=n.replace(/,(\s*[}\]])/g,"$1"),console.log(`üîß Applied block comment removal fix for ${e}`);let s=JSON.parse(n);return console.log(`‚úÖ Fixed block comments in ${e}`),s}catch(s){}try{const s=o.split(`
`);let i=-1,r=0,a=!1,l=!1;for(let d=0;d<o.length;d++){const u=o[d];if(l){l=!1;continue}if(u==="\\"){l=!0;continue}if(u==='"'&&!l){a=!a;continue}if(!a){if(u==="{"||u==="[")r++;else if((u==="}"||u==="]")&&(r--,r===0)){i=d;break}}}if(i>0){const d=o.substring(0,i+1);console.log(`üîß Attempting to truncate extra data after position ${i} for ${e}`);let u=JSON.parse(d);return console.log(`‚úÖ Fixed by truncating extra data in ${e}`),u}}catch(s){}if(console.error(`‚ùå All JSON recovery attempts failed for ${e}`),console.error(`   Original error: ${t instanceof Error?t.message:"Unknown"}`),t instanceof SyntaxError&&t.message.includes("line")){const s=t.message.match(/line (\d+)/);if(s){const i=parseInt(s[1]),r=o.split(`
`),a=Math.max(0,i-3),l=Math.min(r.length,i+2);console.error(`   Context around line ${i}:`);for(let d=a;d<l;d++){const u=d===i-1?">>> ":"    ";console.error(`   ${u}${d+1}: ${r[d]}`)}}}throw t}}function ye(o,e){const t=new Map,n=[],s=[];console.log(`üîç Analyzing ${o.length} token files for multi-brand structure`),console.log("üìã File paths to analyze:",o.map(r=>r.path));for(const r of o){const a=r.path;if(console.log(`  üìÑ Analyzing: ${a}`),!a||typeof a!="string"){console.error("‚ö†Ô∏è  Invalid path provided to detectMultiBrandStructure:",a);continue}if(a.includes("/globals/")||a.includes("globals.json")||a.includes("/global/")||a.includes("global.json"))console.log(`    üåê Found global file: ${a}`),n.push(a);else if(a.includes("/base/")||a.includes("base.json")||a.includes("/core/")||a.includes("core.json")||a.includes("/palette/")||a.includes("palette.json"))console.log(`    üîß Found base file: ${a}`),s.push(a);else{const l=["brands?","themes?","variants?"],d=e?[e,...l]:l;console.log(`üîç Using brand folder patterns: ${d.join(", ")}`);const u=new RegExp(`\\/(${d.join("|")})\\/([^\\/]+)\\/`);let g=a.match(u)||a.match(/\/tokens\/([^\/]+)\//)||a.match(/^([^\/]+)\/tokens\//)||a.match(/^tokens\/([^\/]+)\//);if(g){const f=g[2]||g[1];["globals","global","base","core","palette","foundation","primitives","common"].includes(f.toLowerCase())?(console.log(`    üåê Treating excluded name "${f}" as global: ${a}`),n.push(a)):(console.log(`    üè∑Ô∏è  Found brand: ${f}`),t.has(f)||t.set(f,{name:f,path:g[0],files:[]}),t.get(f).files.push(a))}else console.log(`    üìù Treating as global: ${a}`),n.push(a)}}const i={brands:Array.from(t.values()),globalFiles:n,baseFiles:s};return console.log("‚úÖ Multi-brand analysis complete:"),console.log(`   Brands: ${i.brands.length} (${i.brands.map(r=>r.name).join(", ")})`),console.log(`   Global files: ${i.globalFiles.length}`),console.log(`   Base files: ${i.baseFiles.length}`),i}function we(o){return o.brands.length>0}function _(o){return o.brands.map(e=>e.name)}function ke(o,e){const t=[];for(const n of o){if(n.error){console.warn(`‚ö†Ô∏è  Skipping file with error: ${n.path} - ${n.error}`);continue}try{console.log(`üîç About to parse ${n.path} (${n.content.length} chars)`),console.log(`üìÑ Content preview: ${n.content.substring(0,100)}...`);const s=$e(n.content,n.path);if(console.log(`‚úÖ Successfully parsed ${n.path}`),!s||typeof s!="object"){console.warn(`‚ö†Ô∏è  Invalid token structure in ${n.path}: expected object, got ${typeof s}`);continue}let i="global",r;if(e.baseFiles.includes(n.path))i="base";else{const a=e.brands.find(l=>l.files.includes(n.path));a&&(i="brand",r=a.name)}t.push({path:n.path,content:n.content,tokens:s,brand:r,category:i}),console.log(`üì¶ Processed ${n.path} as ${i}${r?` (brand: ${r})`:""}`)}catch(s){console.error(`‚ùå Failed to parse ${n.path}:`,s)}}return console.log(`‚úÖ Categorized ${t.length} token files`),t}function P(o,e){for(const t in e)e[t]&&typeof e[t]=="object"&&!Array.isArray(e[t])?(o[t]||(o[t]={}),P(o[t],e[t])):o[t]=e[t];return o}function j(o,e=""){const t=[];for(const[n,s]of Object.entries(o)){const i=e?`${e}/${n}`:n;Ce(s)?t.push({path:i,value:s.value,type:s.type,comment:s.comment}):t.push(...j(s,i))}return t}function Ce(o){return o&&typeof o=="object"&&"value"in o}function G(o,e){const t=o==null?void 0:o.toLowerCase();return t==="color"||t==="colorrgb"||t==="colorhex"||t==="colorrgba"?"COLOR":t==="dimension"||t==="size"||t==="sizing"||t==="spacing"||t==="fontsize"||t==="fontweight"||t==="lineheight"||t==="letterSpacing"||t==="opacity"||t==="number"?"FLOAT":t==="boolean"?"BOOLEAN":t==="string"||t==="fontfamily"||t==="fontstyle"||t==="text"?"STRING":typeof e=="boolean"?"BOOLEAN":typeof e=="number"?"FLOAT":typeof e=="string"?e.startsWith("#")||e.startsWith("rgb")||e.startsWith("hsl")?"COLOR":/^\d+(\.\d+)?(px|rem|em|pt|%)$/.test(e)?"FLOAT":"STRING":"STRING"}function D(o,e){if(e==="COLOR"){let t=o;if(typeof o=="object"&&o!==null&&"value"in o&&(t=o.value),typeof t=="string"){const n=pe(t);if(!n)throw new Error(`Invalid color value: ${t}`);return n}throw new Error(`Color value must be a string, got ${typeof t} (original: ${typeof o})`)}if(e==="FLOAT"){if(typeof o=="number")return o;if(typeof o=="string")return me(o);throw new Error(`Float value must be a number or string, got ${typeof o}`)}if(e==="BOOLEAN"){if(typeof o=="boolean")return o;if(typeof o=="string")return o.toLowerCase()==="true";throw new Error(`Boolean value must be a boolean or string, got ${typeof o}`)}return e==="STRING"?String(o):null}function J(o){const e=o.split("/");if(e.length>0){const t=e[0];return t.charAt(0).toUpperCase()+t.slice(1)}return"Tokens"}function Y(o){const e=o.split("/");return e.length>1?e.slice(1).join("/"):e[0]}async function Se(o,e={}){const t={success:!0,collectionsCreated:0,variablesCreated:0,variablesUpdated:0,errors:[],warnings:[]};try{const n=j(o);if(n.length===0)return t.warnings.push("No tokens found to import"),t;console.log(`Found ${n.length} tokens to import`);const s=new Map;for(const i of n){const r=e.collectionName||J(i.path);s.has(r)||s.set(r,[]),s.get(r).push(i)}for(const[i,r]of s)try{const l=(await figma.variables.getLocalVariableCollectionsAsync()).find(f=>f.name===i),d=await X(i);l||t.collectionsCreated++;const u=await Promise.all(d.variableIds.map(async f=>await figma.variables.getVariableByIdAsync(f))),g=new Set(u.filter(f=>f!==null).map(f=>f.name));for(const f of r)try{const c=e.collectionName?f.path:Y(f.path),h=G(f.type,f.value),$=D(f.value,h);if($===null){t.warnings.push(`Skipped token ${f.path}: could not convert value`);continue}const m=g.has(c);e.targetMode?await V(d,c,h,$,e.targetMode,f.comment):await he(d,c,h,$,f.comment),m?t.variablesUpdated++:t.variablesCreated++}catch(c){t.errors.push(`Failed to process token ${f.path}: ${c instanceof Error?c.message:"Unknown error"}`)}}catch(a){t.errors.push(`Failed to process collection ${i}: ${a instanceof Error?a.message:"Unknown error"}`)}t.success=t.errors.length===0}catch(n){t.success=!1,t.errors.push(`Transform failed: ${n instanceof Error?n.message:"Unknown error"}`)}return t}function F(o,e){const t=e||o;if(typeof o=="string"){const n=o.match(/^\{(.+)\}$/);if(n){const s=n[1],i=s.split(".");let r=t;for(const a of i)if(r&&typeof r=="object"&&a in r)r=r[a];else return console.warn(`Token reference not found: ${s}`),o;return F(r,t)}return o}if(Array.isArray(o))return o.map(n=>F(n,t));if(typeof o=="object"&&o!==null){const n={};for(const[s,i]of Object.entries(o))n[s]=F(i,t);return n}return o}async function ve(o,e){const t=o.modes;console.log(`üé® Current modes in collection "${o.name}":`,t.map(r=>`${r.name} (${r.modeId})`));const n=new Set(["Default",...e]),s=new Set(t.map(r=>r.name));console.log("üéØ Required modes:",Array.from(n)),console.log("üìã Existing modes:",Array.from(s));for(const r of e)if(s.has(r))console.log(`‚≠ê Mode "${r}" already exists`);else{console.log(`‚ûï Creating mode for brand: ${r}`);try{const a=o.addMode(r);console.log(`‚úÖ Created mode "${r}" with ID: ${a.modeId}`)}catch(a){throw console.error(`‚ùå Failed to create mode "${r}":`,a),new Error(`Failed to create mode "${r}": ${a instanceof Error?a.message:"Unknown error"}`)}}const i=t.find(r=>r.modeId===o.defaultModeId);if(i&&i.name!=="Default"){console.log(`üîÑ Renaming default mode from "${i.name}" to "Default"`);try{i.name="Default",console.log('‚úÖ Renamed default mode to "Default"')}catch(r){console.error("‚ùå Failed to rename default mode:",r)}}console.log(`‚úÖ Mode setup complete for collection "${o.name}"`)}async function Te(o,e,t={}){const n={success:!0,collectionsCreated:0,variablesCreated:0,variablesUpdated:0,errors:[],warnings:[]};try{if(console.log(`üè¢ Processing ${o.length} files for multi-brand import`),console.log(`üè∑Ô∏è Brands detected: ${e.brands.map(c=>c.name).join(", ")}`),o.length===0)return n.warnings.push("No processed token files provided"),n;console.log("üîß Creating complete token foundation for reference resolution..."),console.log("üìä File categorization:"),console.log(`   Base files: ${o.filter(c=>c.category==="base").length}`),console.log(`   Global files: ${o.filter(c=>c.category==="global").length}`),console.log(`   Brand files: ${o.filter(c=>c.category==="brand").length}`);const s={},i=o.filter(c=>c.category==="base");console.log(`üîß Processing ${i.length} base files...`);for(const c of i)P(s,c.tokens),console.log(`üì¶ Merged base file: ${c.path}`);const r=o.filter(c=>c.category==="global");console.log(`üåê Processing ${r.length} global files...`);for(const c of r)P(s,c.tokens),console.log(`üåê Merged global file: ${c.path}`);const a=o.filter(c=>c.category==="brand");console.log(`üè∑Ô∏è Processing ${a.length} brand files for reference resolution...`);for(const c of a)P(s,c.tokens),console.log(`üé® Merged brand file for reference resolution: ${c.path}`);console.log("üîç Complete tokens after merge:",Object.keys(s)),console.log("üîó Resolving all token references with complete token context...");const l=F(s);console.log("‚úÖ All token references resolved with complete context");const d={};for(const c of[...i,...r])P(d,c.tokens);const u=F(d,l);console.log("‚úÖ Base tokens resolved using complete context");const g=new Map,f=j(u);console.log(`üîß Found ${f.length} base/global tokens`),f.length===0?console.warn("‚ö†Ô∏è  No base tokens found after flattening! Base tokens structure:",d):console.log("üìã Sample base tokens:",f.slice(0,3).map(c=>`${c.path}=${c.value}`));for(const c of f){const h=t.collectionName||J(c.path);g.has(h)||g.set(h,[]),g.get(h).push(c)}for(const[c,h]of g)try{console.log(`üóÇÔ∏è Processing collection: ${c}`);const m=(await figma.variables.getLocalVariableCollectionsAsync()).find(b=>b.name===c),v=await X(c);m||n.collectionsCreated++;const N=e.brands.map(b=>b.name);await ve(v,N);const y=await Promise.all(v.variableIds.map(async b=>await figma.variables.getVariableByIdAsync(b))),O=new Set(y.filter(b=>b!==null).map(b=>b.name));console.log(`üìù Setting base values in Default mode for ${h.length} tokens...`);for(const b of h)try{const R=t.collectionName?b.path:Y(b.path),U=G(b.type,b.value),x=D(b.value,U);if(x===null){n.warnings.push(`Skipped token ${b.path}: could not convert value`);continue}const ee=O.has(R);await V(v,R,U,x,"Default",b.comment),ee?n.variablesUpdated++:n.variablesCreated++,console.log(`‚úÖ Set base value for "${R}" in Default mode`)}catch(R){n.errors.push(`Failed to process base token ${b.path}: ${R instanceof Error?R.message:"Unknown error"}`)}for(const b of e.brands){console.log(`üè∑Ô∏è Processing brand: ${b.name}`);const R=JSON.parse(JSON.stringify(u)),U=o.filter(C=>C.brand===b.name);for(const C of U)P(R,C.tokens),console.log(`üé® Merged brand file for ${b.name}: ${C.path}`);console.log(`üîó Resolving token references for brand: ${b.name}`);const x=F(R,l);console.log(`‚úÖ Token references resolved for brand: ${b.name}`);const oe=j(x).filter(C=>(t.collectionName||J(C.path))===c);console.log(`üéØ Found ${oe.length} tokens for brand ${b.name} in collection ${c}`);for(const C of oe)try{const A=t.collectionName?C.path:Y(C.path),te=G(C.type,C.value),ne=D(C.value,te);if(ne===null)continue;await V(v,A,te,ne,b.name,C.comment),console.log(`üé® Set brand value for "${A}" in mode "${b.name}"`)}catch(A){n.warnings.push(`Failed to set brand value for ${C.path} in brand ${b.name}: ${A instanceof Error?A.message:"Unknown error"}`)}}console.log(`‚úÖ Completed processing collection: ${c}`)}catch($){n.errors.push(`Failed to process collection ${c}: ${$ instanceof Error?$.message:"Unknown error"}`)}n.success=n.errors.length===0,console.log("üéâ Multi-brand transformation complete!"),console.log(`   Collections: ${n.collectionsCreated} created`),console.log(`   Variables: ${n.variablesCreated} created, ${n.variablesUpdated} updated`),console.log(`   Errors: ${n.errors.length}`),console.log(`   Warnings: ${n.warnings.length}`)}catch(s){n.success=!1,n.errors.push(`Multi-brand transform failed: ${s instanceof Error?s.message:"Unknown error"}`)}return n}function Ee(o){try{let e=JSON.parse(o);if(!e||typeof e!="object")throw new Error("Invalid token file: expected JSON object");return e=F(e),e}catch(e){throw e instanceof SyntaxError?new Error(`Invalid JSON: ${e.message}`):e}}function Ne(o){switch(o){case"COLOR":return"color";case"FLOAT":return"dimension";case"STRING":return"string";case"BOOLEAN":return"boolean";default:return"string"}}function Oe(o,e){return e==="COLOR"&&typeof o=="object"&&"r"in o?be(o):e==="FLOAT"&&typeof o=="number"||e==="BOOLEAN"&&typeof o=="boolean"||e==="STRING"&&typeof o=="string"?o:String(o)}function Re(o,e,t){const n=e.split("/");let s=o;for(let r=0;r<n.length-1;r++){const a=n[r];s[a]||(s[a]={}),s=s[a]}const i=n[n.length-1];s[i]=t}function Fe(o){return o.toLowerCase().replace(/\s+/g,"-")}async function Pe(o={}){const e={success:!0,tokens:{},variablesProcessed:0,collectionsProcessed:0,errors:[],warnings:[]};try{const t=await ue();if(t.length===0)return e.warnings.push("No variable collections found in this file"),e;for(const n of t)if(!(o.collectionsToInclude&&!o.collectionsToInclude.includes(n.name)))try{const s=await figma.variables.getVariableCollectionByIdAsync(n.id);if(!s){e.errors.push(`Collection ${n.name} not found`);continue}const i=await Q(s);if(i.length===0){e.warnings.push(`Collection ${n.name} has no variables`);continue}const r=Fe(n.name),a={[r]:{}};for(const l of i)try{const d=s.defaultModeId,u=l.valuesByMode[d];if(u===void 0){e.warnings.push(`Variable ${l.name} has no value for default mode`);continue}const g=Ne(l.resolvedType),c={value:Oe(u,l.resolvedType),type:g};l.description&&(c.comment=l.description);const h=`${r}/${l.name}`;Re(a,h,c),e.variablesProcessed++}catch(d){e.errors.push(`Failed to process variable ${l.name}: ${d instanceof Error?d.message:"Unknown error"}`)}o.organizeByCollection?e.tokens[`${r}.json`]=a:(e.tokens["tokens.json"]||(e.tokens["tokens.json"]={}),Object.assign(e.tokens["tokens.json"],a)),e.collectionsProcessed++}catch(s){e.errors.push(`Failed to process collection ${n.name}: ${s instanceof Error?s.message:"Unknown error"}`)}e.success=e.errors.length===0}catch(t){e.success=!1,e.errors.push(`Transform failed: ${t instanceof Error?t.message:"Unknown error"}`)}return e}function Ae(o){return JSON.stringify(o,null,2)}function Ie(o,e){const t={added:[],modified:[],removed:[]},n=(r,a="")=>{const l=new Map;for(const[d,u]of Object.entries(r)){const g=a?`${a}.${d}`:d;u&&typeof u=="object"&&"value"in u?l.set(g,u):u&&typeof u=="object"&&n(u,g).forEach((c,h)=>l.set(h,c))}return l},s=n(o),i=n(e);return i.forEach((r,a)=>{if(!s.has(a))t.added.push(a);else{const l=s.get(a);JSON.stringify(l)!==JSON.stringify(r)&&t.modified.push(a)}}),s.forEach((r,a)=>{i.has(a)||t.removed.push(a)}),t}async function Me(o,e){const t=o.getConfig();try{const s=(await ce(o,e.baseBranch)).object.sha,r=`figma-tokens-${Date.now()}`;await de(o,r,s),console.log(`Created branch: ${r}`);for(const l of e.files)try{let d="";try{d=(await o.request(`/repos/${t.owner}/${t.repo}/contents/${l.path}?ref=${e.baseBranch}`)).sha}catch(u){console.log(`File ${l.path} doesn't exist, will create new`)}await le(o,{path:l.path,content:l.content,message:`Update ${l.path} from Figma`,sha:d,branch:r}),console.log(`Updated ${l.path} on branch ${r}`)}catch(d){throw console.error(`Failed to update ${l.path}:`,d),new Error(`Failed to update ${l.path}: ${d instanceof Error?d.message:"Unknown error"}`)}const a=await o.request(`/repos/${t.owner}/${t.repo}/pulls`,{method:"POST",body:JSON.stringify({title:e.title,body:e.body,head:r,base:e.baseBranch})});return{success:!0,prUrl:a.html_url,prNumber:a.number,message:`Pull request created: ${a.html_url}`}}catch(n){return console.error("Failed to create PR:",n),{success:!1,message:`Failed to create pull request: ${n instanceof Error?n.message:"Unknown error"}`}}}function _e(o){if(o.added.length+o.modified.length+o.removed.length===0)return"Update design tokens from Figma";const t=[];return o.added.length>0&&t.push(`${o.added.length} added`),o.modified.length>0&&t.push(`${o.modified.length} modified`),o.removed.length>0&&t.push(`${o.removed.length} removed`),`Update design tokens from Figma (${t.join(", ")})`}function je(o,e){const t=[];return t.push("## Summary"),t.push(""),t.push("This PR updates design tokens exported from Figma variables."),t.push(""),t.push(`- **Collections processed:** ${e.collectionsProcessed}`),t.push(`- **Variables processed:** ${e.variablesProcessed}`),t.push(""),o.added.length>0||o.modified.length>0||o.removed.length>0?(t.push("## Changes"),t.push(""),o.added.length>0&&(t.push(`### ‚ú® Added (${o.added.length})`),t.push(""),o.added.slice(0,20).forEach(s=>{t.push(`- \`${s}\``)}),o.added.length>20&&t.push(`- ... and ${o.added.length-20} more`),t.push("")),o.modified.length>0&&(t.push(`### üîÑ Modified (${o.modified.length})`),t.push(""),o.modified.slice(0,20).forEach(s=>{t.push(`- \`${s}\``)}),o.modified.length>20&&t.push(`- ... and ${o.modified.length-20} more`),t.push("")),o.removed.length>0&&(t.push(`### ‚ùå Removed (${o.removed.length})`),t.push(""),o.removed.slice(0,20).forEach(s=>{t.push(`- \`${s}\``)}),o.removed.length>20&&t.push(`- ... and ${o.removed.length-20} more`),t.push(""))):(t.push("## Changes"),t.push(""),t.push("No token changes detected (formatting or structure updates only)."),t.push("")),t.push("---"),t.push(""),t.push("ü§ñ Generated with [Claude Code](https://claude.com/claude-code)"),t.push(""),t.push("**Note:** Please review the changes carefully before merging."),t.join(`
`)}console.log("üöÄ Plugin loading - Figma Token Sync Plugin Started!"),console.log("üöÄ Build timestamp:",new Date().toISOString()),figma.showUI(__html__,{width:400,height:600,themeColors:!0}),console.log("üöÄ UI shown"),figma.ui.onmessage=async o=>{console.log("Plugin received message:",o.type);try{switch(o.type){case"INIT":{const e=await w();p({type:"SETTINGS_LOADED",settings:e});break}case"SAVE_SETTINGS":{const e=await k(o.settings);p({type:"SETTINGS_SAVED",success:e});break}case"TEST_CONNECTION":{console.log("üîó Plugin received TEST_CONNECTION with config:",{hasToken:!!o.config.token,hasOAuthToken:!!o.config.oauthToken,token:o.config.token?`${o.config.token.substring(0,4)}...${o.config.token.substring(o.config.token.length-4)}`:"none",oauthToken:o.config.oauthToken?`${o.config.oauthToken.substring(0,4)}...${o.config.oauthToken.substring(o.config.oauthToken.length-4)}`:"none",owner:o.config.owner,repo:o.config.repo,branch:o.config.branch}),p({type:"SYNC_PROGRESS",message:"Testing connection..."});const e=await Ue(o.config);console.log("üîó Test connection result:",e),p({type:"CONNECTION_TESTED",success:e.success,message:e.message});break}case"PULL_FROM_GITHUB":{p({type:"SYNC_STARTED",direction:"pull"});try{const e=await xe(o.config);if(e.success){const t=await w(),n=B(I({},t),{lastSync:{timestamp:Date.now(),direction:"pull",status:"success",message:e.message}});await k(n)}p({type:"SYNC_COMPLETE",success:e.success,message:e.message})}catch(e){const t=e instanceof Error?e.message:"Pull failed";p({type:"SYNC_COMPLETE",success:!1,message:t})}break}case"PUSH_TO_GITHUB":{p({type:"SYNC_STARTED",direction:"push"});try{const e=await Be(o.config);if(e.success){const t=await w(),n=B(I({},t),{lastSync:{timestamp:Date.now(),direction:"push",status:"success",message:e.message}});await k(n)}p({type:"SYNC_COMPLETE",success:e.success,message:e.message,prUrl:e.prUrl})}catch(e){const t=e instanceof Error?e.message:"Push failed";p({type:"SYNC_COMPLETE",success:!1,message:t})}break}case"GET_COLLECTION_MODES":{try{const e=await fe(o.collectionName);p({type:"COLLECTION_MODES",modes:e})}catch(e){console.error("Failed to get collection modes:",e),p({type:"COLLECTION_MODES",modes:[]})}break}case"START_OAUTH_FLOW":{try{p({type:"SYNC_PROGRESS",message:"Starting OAuth flow..."});const e=await M.startDeviceFlow();p({type:"OAUTH_DEVICE_CODE",userCode:e.user_code,verificationUri:e.verification_uri,interval:e.interval,deviceCode:e.device_code})}catch(e){const t=e instanceof Error?e.message:"Failed to start OAuth flow";p({type:"OAUTH_ERROR",message:t})}break}case"POLL_OAUTH_TOKEN":{try{const e=await M.pollForToken(o.deviceCode,o.interval);p({type:"OAUTH_SUCCESS",token:e})}catch(e){const t=e instanceof Error?e.message:"OAuth authentication failed";p({type:"OAUTH_ERROR",message:t})}break}default:console.warn("Unknown message type:",o.type)}}catch(e){console.error("Error handling message:",e);let t="Unknown error occurred";e instanceof T?(t=`GitHub API Error: ${e.message}`,e.status&&(t+=` (Status: ${e.status})`)):e instanceof Error&&(t=e.message),p({type:"ERROR",message:t})}};function p(o){figma.ui.postMessage(o)}async function Ue(o){try{if(!o.token&&!o.oauthToken)return{success:!1,message:"No authentication token provided. Please authenticate with GitHub first."};if(!o.owner||!o.repo)return{success:!1,message:"Repository owner and name are required."};const e=new L(o);p({type:"SYNC_PROGRESS",message:"Verifying credentials..."});const t=await e.testConnection();if(!t.success)return t;if(o.tokenPaths&&o.tokenPaths.length>0){p({type:"SYNC_PROGRESS",message:"Exploring repository structure..."});try{console.log("üîç Attempting to list root directory...");const l=await e.request(`/repos/${o.owner}/${o.repo}/contents?ref=${o.branch||"main"}`);console.log("üóÇÔ∏è Raw root response type:",typeof l,Array.isArray(l)),console.log("üóÇÔ∏è Raw root response sample:",l[0]||l);const d=Array.isArray(l)?l:[l];console.log("üóÇÔ∏è Repository root contents:",d.map(u=>`${u.name||u.filename||"unknown"} (${u.type||"unknown"})`)),p({type:"SYNC_PROGRESS",message:`Repository has ${d.length} items in root: ${d.slice(0,5).map(u=>u.name).join(", ")}${d.length>5?"...":""}`})}catch(l){console.error("Failed to list root directory:",l),p({type:"SYNC_PROGRESS",message:"Could not explore repository structure (continuing...)"})}p({type:"SYNC_PROGRESS",message:"Searching for token files..."});const s=await z(e,o.tokenPaths,o.branch);if(s.length===0)return{success:!1,message:`No token files found matching patterns: ${o.tokenPaths.join(", ")}`};const r=(await e.validateTokenPaths(s)).results.filter(l=>!l.exists);if(r.length>0)return{success:!1,message:`Missing token files: ${r.map(l=>l.path).join(", ")}`};const a=t.details;return{success:!0,message:`‚úì Connected as ${a.user} to ${a.repo} (${a.branch})
‚úì Found ${s.length} token file(s)
‚úì Write access: ${a.hasWriteAccess?"Yes":"No"}`}}const n=t.details;return{success:!0,message:`‚úì Connected as ${n.user} to ${n.repo} (${n.branch})
‚úì Write access: ${n.hasWriteAccess?"Yes":"No"}`}}catch(e){return e instanceof T?{success:!1,message:e.message}:{success:!1,message:e instanceof Error?e.message:"Connection test failed"}}}async function xe(o){try{const e=new L(o);p({type:"SYNC_PROGRESS",message:"Finding token files..."});const t=await z(e,o.tokenPaths,o.branch);if(t.length===0)return{success:!1,message:`No token files found matching patterns: ${o.tokenPaths.join(", ")}`};p({type:"SYNC_PROGRESS",message:`Found ${t.length} token file(s)`}),p({type:"SYNC_PROGRESS",message:"Fetching token files..."});const n=await H(e,t,o.branch),s=n.filter(h=>h.error);if(s.length>0)return{success:!1,message:`Failed to fetch files:
${s.map(h=>`- ${h.path}: ${h.error}`).join(`
`)}`};p({type:"SYNC_PROGRESS",message:"Analyzing token structure..."});const i=ye(t.map(h=>({path:h})),o.brandFolderPattern),r=we(i);console.log(`üè¢ Multi-brand structure detected: ${r}`),r&&console.log(`üè∑Ô∏è Brands found: ${_(i).join(", ")}`),p({type:"SYNC_PROGRESS",message:"Parsing token files..."});const a=ke(n,i);if(a.length===0)return{success:!1,message:"No valid token files found to process"};p({type:"SYNC_PROGRESS",message:"Creating Figma variables..."});let l=0,d=0,u=0;const g=[],f=[];try{if(r&&o.modeStrategy!=="target"){p({type:"SYNC_PROGRESS",message:"Processing multi-brand tokens with automatic mode creation..."});const $={collectionName:o.targetCollection||void 0};console.log("üéØ Multi-brand transform options:",$),console.log("üé® Mode strategy: auto (create modes from brand names)");const m=await Te(a,i,$);l+=m.collectionsCreated,d+=m.variablesCreated,u+=m.variablesUpdated,g.push(...m.errors),f.push(...m.warnings),m.success||console.error("Failed to transform multi-brand tokens:",m.errors)}else{p({type:"SYNC_PROGRESS",message:r?"Processing multi-brand tokens with target mode strategy...":"Processing single-brand tokens..."});const m={};for(const O of a)Object.assign(m,O.tokens),console.log(`üì¶ Merged tokens from ${O.path}`);const v=F(m);console.log(`üîó Resolved ${Object.keys(m).length} top-level token groups`);const N={collectionName:o.targetCollection||void 0,targetMode:o.targetMode||void 0};r?(console.log("üéØ Multi-brand target mode transform options:",N),console.log("üé® Mode strategy: target (use specified target mode instead of brand modes)")):console.log("üéØ Single-brand transform options:",N);const y=await Se(v,N);l+=y.collectionsCreated,d+=y.variablesCreated,u+=y.variablesUpdated,g.push(...y.errors),f.push(...y.warnings),y.success||console.error("Failed to transform tokens:",y.errors)}}catch(h){const $=`Failed to process tokens: ${h instanceof Error?h.message:"Unknown error"}`;g.push($),console.error($)}if(g.length>0)return{success:!1,message:`Sync completed with errors:
${g.slice(0,5).join(`
`)}${g.length>5?`
... and ${g.length-5} more errors`:""}`};const c=[`‚úì Successfully imported ${n.length} token file(s)`,r?`‚úì Multi-brand structure with ${_(i).length} brands: ${_(i).join(", ")}`:"‚úì Single-brand structure",`‚úì Collections: ${l} created`,`‚úì Variables: ${d} created, ${u} updated`];return r&&c.push(`‚úì Modes created: Default + ${_(i).join(", ")}`),f.length>0&&c.push(`‚ö† Warnings: ${f.length}`),{success:!0,message:c.join(`
`)}}catch(e){return console.error("Pull failed:",e),e instanceof T?{success:!1,message:`GitHub API Error: ${e.message}`}:{success:!1,message:e instanceof Error?e.message:"Pull failed"}}}async function Be(o){try{const e=new L(o);p({type:"SYNC_PROGRESS",message:"Reading Figma variables..."});const t=await Pe({organizeByCollection:!0});if(!t.success)return{success:!1,message:`Failed to read variables:
${t.errors.join(`
`)}`};if(t.variablesProcessed===0)return{success:!1,message:"No variables found in this file. Create some variables first!"};p({type:"SYNC_PROGRESS",message:`Read ${t.variablesProcessed} variables from ${t.collectionsProcessed} collection(s)`}),p({type:"SYNC_PROGRESS",message:"Preparing token files..."});const n=[];for(const[d,u]of Object.entries(t.tokens)){let g;if(o.tokenPaths.length===1&&!o.tokenPaths[0].includes("*"))g=o.tokenPaths[0];else{const c=o.tokenPaths[0]||"tokens/**/*.json";let h="tokens";if(c.includes("/")){const $=c.split("/"),m=$.filter(v=>!v.includes("*"));m.length>0?h=m.join("/"):h=$[0]==="."?"tokens":$[0]}g=`${h}/${d}`}console.log(`üìÅ Generated file path: ${g} for collection file: ${d}`);const f=Ae(u);n.push({path:g,content:f})}p({type:"SYNC_PROGRESS",message:"Generating changelog..."});let s={added:[],modified:[],removed:[]};for(const d of n)try{const u=await H(e,[d.path],o.branch);if(u[0]&&!u[0].error){const g=Ee(u[0].content),f=JSON.parse(d.content),c=Ie(g,f);s.added.push(...c.added),s.modified.push(...c.modified),s.removed.push(...c.removed)}else{const g=JSON.parse(d.content),f=h=>{let $=0;for(const m of Object.values(h))m&&typeof m=="object"&&"value"in m?$++:m&&typeof m=="object"&&($+=f(m));return $},c=f(g);s.added.push(`${d.path} (${c} tokens)`)}}catch(u){console.warn(`Could not fetch ${d.path} for comparison:`,u)}p({type:"SYNC_PROGRESS",message:"Creating Pull Request..."});const i=_e(s),r=je(s,{collectionsProcessed:t.collectionsProcessed,variablesProcessed:t.variablesProcessed}),a=await Me(e,{title:i,body:r,baseBranch:o.branch||"main",files:n});return a.success?{success:!0,message:["‚úì Successfully created Pull Request",`‚úì Files: ${n.length} updated`,`‚úì Variables: ${t.variablesProcessed} exported`,`‚úì PR: ${a.prUrl}`].join(`
`),prUrl:a.prUrl}:{success:!1,message:a.message}}catch(e){return console.error("Push failed:",e),e instanceof T?{success:!1,message:`GitHub API Error: ${e.message}`}:{success:!1,message:e instanceof Error?e.message:"Push failed"}}}})();
