var Ie=Object.defineProperty,Me=Object.defineProperties;var je=Object.getOwnPropertyDescriptors;var Z=Object.getOwnPropertySymbols;var Ue=Object.prototype.hasOwnProperty,Ve=Object.prototype.propertyIsEnumerable;var ee=(k,$,C)=>$ in k?Ie(k,$,{enumerable:!0,configurable:!0,writable:!0,value:C}):k[$]=C,R=(k,$)=>{for(var C in $||($={}))Ue.call($,C)&&ee(k,C,$[C]);if(Z)for(var C of Z($))Ve.call($,C)&&ee(k,C,$[C]);return k},M=(k,$)=>Me(k,je($));(function(){"use strict";const k="plugin-settings";async function $(){try{return await figma.clientStorage.getAsync(k)||{}}catch(t){return console.error("Failed to load settings:",t),{}}}async function C(t){try{return await figma.clientStorage.setAsync(k,t),!0}catch(e){return console.error("Failed to save settings:",e),!1}}class v extends Error{constructor(e,o,s){super(e),this.name="GitHubAPIError",this.status=o,this.documentation_url=s}}class j{constructor(e){this.baseUrl="https://api.github.com",this.config=e}getConfig(){return this.config}getAuthToken(){return this.config.oauthToken||this.config.token||""}async request(e,o={}){var n,i;const s=e.startsWith("http")?e:`${this.baseUrl}${e}`,r=this.getAuthToken();if(!r)throw new v("No authentication token provided");const a=R({Authorization:`Bearer ${r}`,Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"},o.headers);try{const c=await fetch(s,M(R({},o),{headers:a}));if(c.status===429){const u=(n=c.headers)==null?void 0:n.get("X-RateLimit-Reset");throw new v(`Rate limit exceeded. Resets at ${u?new Date(parseInt(u)*1e3).toLocaleString():"unknown"}`,429)}const l=(i=c.headers)==null?void 0:i.get("content-type");let d;if(l!=null&&l.includes("application/json"))d=await c.json();else{const u=await c.text();try{d=JSON.parse(u)}catch(f){d=u}}if(!c.ok){const u=(d==null?void 0:d.message)||`HTTP ${c.status}: ${c.statusText}`;throw new v(u,c.status,d==null?void 0:d.documentation_url)}return d}catch(c){throw c instanceof v?c:new v(c instanceof Error?c.message:"Unknown error occurred")}}async getRepository(){return this.request(`/repos/${this.config.owner}/${this.config.repo}`)}async getBranch(e){const o=e||this.config.branch||"main";return this.request(`/repos/${this.config.owner}/${this.config.repo}/branches/${o}`)}async getUser(){return this.request("/user")}async testConnection(){var e,o;try{const s=await this.getUser(),r=await this.getRepository(),a=await this.getBranch(),n=((e=r.permissions)==null?void 0:e.push)||((o=r.permissions)==null?void 0:o.admin)||!1;return{success:!0,message:`Connected as ${s.login} to ${r.full_name}`,details:{user:s.login,repo:r.full_name,branch:a.name,hasWriteAccess:n}}}catch(s){if(s instanceof v){let r=s.message;return s.status===401?r="Invalid token. Please check your Personal Access Token.":s.status===404?r="Repository not found. Check owner/repo or token permissions.":s.status===403&&(r="Access forbidden. Your token may lack required permissions."),{success:!1,message:r}}return{success:!1,message:s instanceof Error?s.message:"Connection test failed"}}}async validateTokenPaths(e){const o=await Promise.all(e.map(async s=>{try{return await this.request(`/repos/${this.config.owner}/${this.config.repo}/contents/${s}?ref=${this.config.branch||"main"}`),{path:s,exists:!0}}catch(r){return r instanceof v&&r.status===404?{path:s,exists:!1,error:"File not found"}:{path:s,exists:!1,error:r instanceof Error?r.message:"Unknown error"}}}));return{valid:o.every(s=>s.exists),results:o}}}const E=class E{static async startDeviceFlow(){const e=await fetch(E.DEVICE_CODE_URL,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify({client_id:E.CLIENT_ID,scope:"repo"})});if(!e.ok)throw new Error(`Failed to start device flow: ${e.statusText}`);return e.json()}static async pollForToken(e,o=5){return new Promise((s,r)=>{const a=async()=>{try{const i=await(await fetch(E.ACCESS_TOKEN_URL,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify({client_id:E.CLIENT_ID,device_code:e,grant_type:"urn:ietf:params:oauth:grant-type:device_code"})})).json();if("access_token"in i){s(i.access_token);return}if("error"in i)switch(i.error){case"authorization_pending":setTimeout(a,o*1e3);break;case"slow_down":setTimeout(a,(o+5)*1e3);break;case"expired_token":case"access_denied":r(new Error(i.error_description||i.error));break;default:r(new Error(`OAuth error: ${i.error}`))}}catch(n){r(n)}};a()})}};E.CLIENT_ID="your_github_app_client_id",E.DEVICE_CODE_URL="https://github.com/login/device/code",E.ACCESS_TOKEN_URL="https://github.com/login/oauth/access_token";let F=E;async function te(t,e,o){const s=t.getConfig(),r=o||s.branch||"main",a=await t.request(`/repos/${s.owner}/${s.repo}/contents/${e}?ref=${r}`);console.log(`ðŸ“„ Raw file response for ${e}:`,typeof a,a),console.log("ðŸ“„ Response keys:",Object.keys(a)),console.log("ðŸ“„ Has content field:","content"in a),console.log("ðŸ“„ File size:",a.size);const n=Array.isArray(a)?a[0]:a;if(n.size>1048576)throw new Error(`File ${e} is too large (${n.size} bytes). GitHub API doesn't return content for files over 1MB.`);if(!n.content){if(console.log("ðŸ“„ File metadata only, attempting download_url:",n.download_url),n.download_url){const c=await fetch(n.download_url);if(!c.ok)throw new Error(`Failed to fetch raw content for ${e}: ${c.status} ${c.statusText}`);return{content:await c.text(),sha:n.sha||"unknown",path:n.path||e}}throw new Error(`No content found for file ${e} and no download_url available`)}console.log(`ðŸ“„ Content type for ${e}:`,typeof n.content),console.log(`ðŸ“„ Content encoding for ${e}:`,n.encoding),console.log(`ðŸ“„ Content preview for ${e}:`,String(n.content).substring(0,100));const i=typeof n.content=="string"?n.content:String(n.content);try{let c=function(u){const f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";let m="",p=0;for(u=u.replace(/=+$/,"");p<u.length;){const b=f.indexOf(u.charAt(p++)),y=f.indexOf(u.charAt(p++)),g=f.indexOf(u.charAt(p++)),w=f.indexOf(u.charAt(p++)),T=b<<18|y<<12|g<<6|w;m+=String.fromCharCode(T>>16&255),g!==-1&&(m+=String.fromCharCode(T>>8&255)),w!==-1&&(m+=String.fromCharCode(T&255))}return m};const l=i.replace(/\n/g,"").replace(/\s/g,"");let d;return typeof atob!="undefined"?d=atob(l):d=c(l),console.log(`ðŸ“„ Successfully decoded ${e}, length: ${d.length}`),console.log(`ðŸ“„ Content preview for ${e}:`,d.substring(0,100)),{content:d,sha:n.sha||"unknown",path:n.path||e}}catch(c){throw console.error(`ðŸ“„ Failed to decode base64 content for ${e}:`,c),new Error(`Failed to decode content for ${e}: ${c instanceof Error?c.message:"Unknown error"}`)}}async function x(t,e,o){return await Promise.all(e.map(async r=>{try{return await te(t,r,o)}catch(a){return{content:"",sha:"",path:r,error:a instanceof Error?a.message:"Failed to fetch file"}}}))}function oe(t){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";let o="",s=0;for(;s<t.length;){const r=t.charCodeAt(s++),a=s<t.length?t.charCodeAt(s++):0,n=s<t.length?t.charCodeAt(s++):0,i=r<<16|a<<8|n;o+=e.charAt(i>>18&63),o+=e.charAt(i>>12&63),o+=s-2<t.length?e.charAt(i>>6&63):"=",o+=s-1<t.length?e.charAt(i&63):"="}return o}async function se(t,e){const o=t.getConfig();let s;typeof btoa!="undefined"?s=btoa(e.content):s=oe(e.content);const r={message:e.message,content:s,sha:e.sha,branch:e.branch};return t.request(`/repos/${o.owner}/${o.repo}/contents/${e.path}`,{method:"PUT",body:JSON.stringify(r)})}async function ne(t,e){const o=t.getConfig();return t.request(`/repos/${o.owner}/${o.repo}/git/refs/heads/${e}`)}async function re(t,e,o){const s=t.getConfig();return t.request(`/repos/${s.owner}/${s.repo}/git/refs`,{method:"POST",body:JSON.stringify({ref:`refs/heads/${e}`,sha:o})})}async function Y(t,e,o){const s=t.getConfig(),r=o||s.branch||"main",a=await t.request(`/repos/${s.owner}/${s.repo}/contents/${e}?ref=${r}`),n=Array.isArray(a)?a:[a];return console.log(`ðŸ“‹ Raw GitHub API response for ${e}:`,n.length,"items"),n.length>0&&console.log("ðŸ“‹ Sample item structure:",n[0]),n.map(i=>({name:i.name||i.filename||"unknown",path:i.path||i.full_name||"unknown",type:i.type||"unknown",sha:i.sha||"unknown"}))}async function H(t,e,o){const s=[];console.log(`ðŸ” Searching for token files with patterns: ${e.join(", ")}`);for(const a of e)if(console.log(`ðŸ“‚ Processing pattern: ${a}`),a.includes("*"))if(a.includes("**")){const n=a.split("**")[0].replace(/\/$/,"");console.log(`ðŸ”„ Recursive search in: ${n||"root"}`);try{const i=await J(t,n||"",o);console.log(`ðŸ“‹ Found ${i.length} total files in ${n||"root"}`);const c=i.filter(l=>l.endsWith(".json"));console.log(`ðŸ“„ Found ${c.length} JSON files: ${c.join(", ")}`),s.push(...c)}catch(i){console.error(`âŒ Failed recursive search in ${n}:`,i)}}else{const n=a.split("*")[0].replace(/\/$/,"");console.log(`ðŸ“ Listing directory: ${n||"root"}`);try{const i=await Y(t,n,o);console.log(`ðŸ“‹ Found ${i.length} items in ${n||"root"}:`,i.map(l=>`${l.name} (${l.type})`));const c=i.filter(l=>l.type==="file"&&l.name.endsWith(".json")).map(l=>l.path);console.log(`ðŸ“„ Filtered to ${c.length} JSON files: ${c.join(", ")}`),s.push(...c)}catch(i){console.error(`âŒ Failed to list directory ${n}:`,i)}}else console.log(`ðŸ“Œ Adding direct file path: ${a}`),s.push(a);const r=[...new Set(s)];return console.log(`âœ… Final result: ${r.length} unique files found: ${r.join(", ")}`),r}async function J(t,e,o,s=[]){try{const r=await Y(t,e,o);for(const a of r)a.type==="file"?s.push(a.path):a.type==="dir"&&await J(t,a.path,o,s)}catch(r){console.warn(`Failed to list directory ${e}:`,r)}return s}async function ae(){return(await figma.variables.getLocalVariableCollectionsAsync()).map(e=>({id:e.id,name:e.name,modes:e.modes,defaultModeId:e.defaultModeId,variableIds:e.variableIds}))}async function q(t){return(await figma.variables.getLocalVariableCollectionsAsync()).find(o=>o.name===t)||null}async function W(t){let e=await q(t);return e||(e=figma.variables.createVariableCollection(t),console.log(`Created variable collection: ${t}`)),e}async function ie(t){try{const e=await q(t);return e?e.modes.map(o=>({modeId:o.modeId,name:o.name})):(console.log(`Collection "${t}" not found`),[])}catch(e){return console.error(`Failed to get modes for collection "${t}":`,e),[]}}function ce(t,e){if(!e)return t.defaultModeId;const o=t.modes.find(s=>s.name===e);return o?o.modeId:(console.warn(`Mode "${e}" not found in collection "${t.name}", using default mode`),t.defaultModeId)}async function z(t){return(await Promise.all(t.variableIds.map(async o=>await figma.variables.getVariableByIdAsync(o)))).filter(o=>o!==null)}async function K(t,e){return(await z(t)).find(s=>s.name===e)||null}async function le(t,e,o,s,r){let a=await K(t,e);a?a.resolvedType!==o&&(console.warn(`Variable ${e} type mismatch: expected ${o}, found ${a.resolvedType}`),a.id,a.remove(),a=figma.variables.createVariable(e,t,o),console.log(`Recreated variable: ${e} with new type ${o}`)):(a=figma.variables.createVariable(e,t,o),console.log(`Created variable: ${e} (${o})`));const n=t.defaultModeId;return a.setValueForMode(n,s),r&&(a.description=r),a}async function U(t,e,o,s,r,a){let n=await K(t,e);n?n.resolvedType!==o&&(console.warn(`Variable ${e} type mismatch: expected ${o}, found ${n.resolvedType}`),n.id,n.remove(),n=figma.variables.createVariable(e,t,o),console.log(`Recreated variable: ${e} with new type ${o}`)):(n=figma.variables.createVariable(e,t,o),console.log(`Created variable: ${e} (${o})`));const i=ce(t,r),c=r||"default";return n.setValueForMode(i,s),console.log(`Set variable ${e} in mode "${c}"`),a&&(n.description=a),n}function de(t){const e=t.trim();if(e.startsWith("#")){let s=e.slice(1);if(s.length===3&&(s=s.split("").map(r=>r+r).join("")),s.length===6||s.length===8){const r=parseInt(s.slice(0,2),16)/255,a=parseInt(s.slice(2,4),16)/255,n=parseInt(s.slice(4,6),16)/255,i=s.length===8?parseInt(s.slice(6,8),16)/255:1;return{r,g:a,b:n,a:i}}}const o=e.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+)\s*)?\)/);if(o){const s=parseInt(o[1])/255,r=parseInt(o[2])/255,a=parseInt(o[3])/255,n=o[4]?parseFloat(o[4]):1;return{r:s,g:r,b:a,a:n}}return null}function ue(t){const e=t.trim(),o=e.match(/^([\d.]+)/);if(o)return parseFloat(o[1]);const s=parseFloat(e);return isNaN(s)?0:s}function fe(t){const e=Math.round(t.r*255).toString(16).padStart(2,"0"),o=Math.round(t.g*255).toString(16).padStart(2,"0"),s=Math.round(t.b*255).toString(16).padStart(2,"0");if(t.a<1){const r=Math.round(t.a*255).toString(16).padStart(2,"0");return`#${e}${o}${s}${r}`}return`#${e}${o}${s}`}function ge(t){const e=new Map,o=[],s=[];console.log(`ðŸ” Analyzing ${t.length} token files for multi-brand structure`);for(const a of t){const n=a.path;console.log(`  ðŸ“„ Analyzing: ${n}`);const i=n.match(/\/(?:brands?|themes?|variants?)\/([^\/]+)\//);if(i){const c=i[1];console.log(`    ðŸ·ï¸  Found brand: ${c}`),e.has(c)||e.set(c,{name:c,path:i[0],files:[]}),e.get(c).files.push(n)}else n.includes("/global/")||n.includes("global.json")||n.includes("globals.json")?(console.log(`    ðŸŒ Found global file: ${n}`),o.push(n)):n.includes("/base/")||n.includes("base.json")||n.includes("/core/")||n.includes("core.json")?(console.log(`    ðŸ”§ Found base file: ${n}`),s.push(n)):(console.log(`    ðŸ“ Treating as global: ${n}`),o.push(n))}const r={brands:Array.from(e.values()),globalFiles:o,baseFiles:s};return console.log("âœ… Multi-brand analysis complete:"),console.log(`   Brands: ${r.brands.length} (${r.brands.map(a=>a.name).join(", ")})`),console.log(`   Global files: ${r.globalFiles.length}`),console.log(`   Base files: ${r.baseFiles.length}`),r}function he(t){return t.brands.length>0}function P(t){return t.brands.map(e=>e.name)}function pe(t,e){const o=[];for(const s of t){if(s.error){console.warn(`âš ï¸  Skipping file with error: ${s.path} - ${s.error}`);continue}try{const r=JSON.parse(s.content);let a="global",n;if(e.baseFiles.includes(s.path))a="base";else{const i=e.brands.find(c=>c.files.includes(s.path));i&&(a="brand",n=i.name)}o.push({path:s.path,content:s.content,tokens:r,brand:n,category:a}),console.log(`ðŸ“¦ Processed ${s.path} as ${a}${n?` (brand: ${n})`:""}`)}catch(r){console.error(`âŒ Failed to parse ${s.path}:`,r)}}return console.log(`âœ… Categorized ${o.length} token files`),o}function _(t,e){for(const o in e)e[o]&&typeof e[o]=="object"&&!Array.isArray(e[o])?(t[o]||(t[o]={}),_(t[o],e[o])):t[o]=e[o];return t}function A(t,e=""){const o=[];for(const[s,r]of Object.entries(t)){const a=e?`${e}/${s}`:s;me(r)?o.push({path:a,value:r.value,type:r.type,comment:r.comment}):o.push(...A(r,a))}return o}function me(t){return t&&typeof t=="object"&&"value"in t}function V(t,e){const o=t==null?void 0:t.toLowerCase();return o==="color"||o==="colorrgb"||o==="colorhex"||o==="colorrgba"?"COLOR":o==="dimension"||o==="size"||o==="sizing"||o==="spacing"||o==="fontsize"||o==="fontweight"||o==="lineheight"||o==="letterSpacing"||o==="opacity"||o==="number"?"FLOAT":o==="boolean"?"BOOLEAN":o==="string"||o==="fontfamily"||o==="fontstyle"||o==="text"?"STRING":typeof e=="boolean"?"BOOLEAN":typeof e=="number"?"FLOAT":typeof e=="string"?e.startsWith("#")||e.startsWith("rgb")||e.startsWith("hsl")?"COLOR":/^\d+(\.\d+)?(px|rem|em|pt|%)$/.test(e)?"FLOAT":"STRING":"STRING"}function L(t,e){if(e==="COLOR"){let o=t;if(typeof t=="object"&&t!==null&&"value"in t&&(o=t.value),typeof o=="string"){const s=de(o);if(!s)throw new Error(`Invalid color value: ${o}`);return s}throw new Error(`Color value must be a string, got ${typeof o} (original: ${typeof t})`)}if(e==="FLOAT"){if(typeof t=="number")return t;if(typeof t=="string")return ue(t);throw new Error(`Float value must be a number or string, got ${typeof t}`)}if(e==="BOOLEAN"){if(typeof t=="boolean")return t;if(typeof t=="string")return t.toLowerCase()==="true";throw new Error(`Boolean value must be a boolean or string, got ${typeof t}`)}return e==="STRING"?String(t):null}function B(t){const e=t.split("/");if(e.length>0){const o=e[0];return o.charAt(0).toUpperCase()+o.slice(1)}return"Tokens"}function G(t){const e=t.split("/");return e.length>1?e.slice(1).join("/"):e[0]}async function be(t,e={}){const o={success:!0,collectionsCreated:0,variablesCreated:0,variablesUpdated:0,errors:[],warnings:[]};try{const s=A(t);if(s.length===0)return o.warnings.push("No tokens found to import"),o;console.log(`Found ${s.length} tokens to import`);const r=new Map;for(const a of s){const n=e.collectionName||B(a.path);r.has(n)||r.set(n,[]),r.get(n).push(a)}for(const[a,n]of r)try{const c=(await figma.variables.getLocalVariableCollectionsAsync()).find(f=>f.name===a),l=await W(a);c||o.collectionsCreated++;const d=await Promise.all(l.variableIds.map(async f=>await figma.variables.getVariableByIdAsync(f))),u=new Set(d.filter(f=>f!==null).map(f=>f.name));for(const f of n)try{const m=e.collectionName?f.path:G(f.path),p=V(f.type,f.value),b=L(f.value,p);if(b===null){o.warnings.push(`Skipped token ${f.path}: could not convert value`);continue}const y=u.has(m);e.targetMode?await U(l,m,p,b,e.targetMode,f.comment):await le(l,m,p,b,f.comment),y?o.variablesUpdated++:o.variablesCreated++}catch(m){o.errors.push(`Failed to process token ${f.path}: ${m instanceof Error?m.message:"Unknown error"}`)}}catch(i){o.errors.push(`Failed to process collection ${a}: ${i instanceof Error?i.message:"Unknown error"}`)}o.success=o.errors.length===0}catch(s){o.success=!1,o.errors.push(`Transform failed: ${s instanceof Error?s.message:"Unknown error"}`)}return o}function O(t,e){const o=e||t;if(typeof t=="string"){const s=t.match(/^\{(.+)\}$/);if(s){const r=s[1],a=r.split(".");let n=o;for(const i of a)if(n&&typeof n=="object"&&i in n)n=n[i];else return console.warn(`Token reference not found: ${r}`),t;return O(n,o)}return t}if(Array.isArray(t))return t.map(s=>O(s,o));if(typeof t=="object"&&t!==null){const s={};for(const[r,a]of Object.entries(t))s[r]=O(a,o);return s}return t}async function ye(t,e){const o=t.modes;console.log(`ðŸŽ¨ Current modes in collection "${t.name}":`,o.map(n=>`${n.name} (${n.modeId})`));const s=new Set(["Default",...e]),r=new Set(o.map(n=>n.name));console.log("ðŸŽ¯ Required modes:",Array.from(s)),console.log("ðŸ“‹ Existing modes:",Array.from(r));for(const n of e)if(r.has(n))console.log(`â­ Mode "${n}" already exists`);else{console.log(`âž• Creating mode for brand: ${n}`);try{const i=t.addMode(n);console.log(`âœ… Created mode "${n}" with ID: ${i.modeId}`)}catch(i){throw console.error(`âŒ Failed to create mode "${n}":`,i),new Error(`Failed to create mode "${n}": ${i instanceof Error?i.message:"Unknown error"}`)}}const a=o.find(n=>n.modeId===t.defaultModeId);if(a&&a.name!=="Default"){console.log(`ðŸ”„ Renaming default mode from "${a.name}" to "Default"`);try{a.name="Default",console.log('âœ… Renamed default mode to "Default"')}catch(n){console.error("âŒ Failed to rename default mode:",n)}}console.log(`âœ… Mode setup complete for collection "${t.name}"`)}async function $e(t,e,o={}){const s={success:!0,collectionsCreated:0,variablesCreated:0,variablesUpdated:0,errors:[],warnings:[]};try{if(console.log(`ðŸ¢ Processing ${t.length} files for multi-brand import`),console.log(`ðŸ·ï¸ Brands detected: ${e.brands.map(l=>l.name).join(", ")}`),t.length===0)return s.warnings.push("No processed token files provided"),s;console.log("ðŸ”§ Creating base token foundation...");const r={},a=t.filter(l=>l.category==="base");for(const l of a)_(r,l.tokens),console.log(`ðŸ“¦ Merged base file: ${l.path}`);const n=t.filter(l=>l.category==="global");for(const l of n)_(r,l.tokens),console.log(`ðŸŒ Merged global file: ${l.path}`);const i=new Map,c=A(r);console.log(`ðŸ”§ Found ${c.length} base/global tokens`);for(const l of c){const d=o.collectionName||B(l.path);i.has(d)||i.set(d,[]),i.get(d).push(l)}for(const[l,d]of i)try{console.log(`ðŸ—‚ï¸ Processing collection: ${l}`);const f=(await figma.variables.getLocalVariableCollectionsAsync()).find(g=>g.name===l),m=await W(l);f||s.collectionsCreated++;const p=e.brands.map(g=>g.name);await ye(m,p);const b=await Promise.all(m.variableIds.map(async g=>await figma.variables.getVariableByIdAsync(g))),y=new Set(b.filter(g=>g!==null).map(g=>g.name));console.log(`ðŸ“ Setting base values in Default mode for ${d.length} tokens...`);for(const g of d)try{const w=o.collectionName?g.path:G(g.path),T=V(g.type,g.value),D=L(g.value,T);if(D===null){s.warnings.push(`Skipped token ${g.path}: could not convert value`);continue}const I=y.has(w);await U(m,w,T,D,"Default",g.comment),I?s.variablesUpdated++:s.variablesCreated++,console.log(`âœ… Set base value for "${w}" in Default mode`)}catch(w){s.errors.push(`Failed to process base token ${g.path}: ${w instanceof Error?w.message:"Unknown error"}`)}for(const g of e.brands){console.log(`ðŸ·ï¸ Processing brand: ${g.name}`);const w=JSON.parse(JSON.stringify(r)),T=t.filter(S=>S.brand===g.name);for(const S of T)_(w,S.tokens),console.log(`ðŸŽ¨ Merged brand file for ${g.name}: ${S.path}`);const I=A(w).filter(S=>(o.collectionName||B(S.path))===l);console.log(`ðŸŽ¯ Found ${I.length} tokens for brand ${g.name} in collection ${l}`);for(const S of I)try{const N=o.collectionName?S.path:G(S.path),X=V(S.type,S.value),Q=L(S.value,X);if(Q===null)continue;await U(m,N,X,Q,g.name,S.comment),console.log(`ðŸŽ¨ Set brand value for "${N}" in mode "${g.name}"`)}catch(N){s.warnings.push(`Failed to set brand value for ${S.path} in brand ${g.name}: ${N instanceof Error?N.message:"Unknown error"}`)}}console.log(`âœ… Completed processing collection: ${l}`)}catch(u){s.errors.push(`Failed to process collection ${l}: ${u instanceof Error?u.message:"Unknown error"}`)}s.success=s.errors.length===0,console.log("ðŸŽ‰ Multi-brand transformation complete!"),console.log(`   Collections: ${s.collectionsCreated} created`),console.log(`   Variables: ${s.variablesCreated} created, ${s.variablesUpdated} updated`),console.log(`   Errors: ${s.errors.length}`),console.log(`   Warnings: ${s.warnings.length}`)}catch(r){s.success=!1,s.errors.push(`Multi-brand transform failed: ${r instanceof Error?r.message:"Unknown error"}`)}return s}function we(t){try{let e=JSON.parse(t);if(!e||typeof e!="object")throw new Error("Invalid token file: expected JSON object");return e=O(e),e}catch(e){throw e instanceof SyntaxError?new Error(`Invalid JSON: ${e.message}`):e}}function Ce(t){switch(t){case"COLOR":return"color";case"FLOAT":return"dimension";case"STRING":return"string";case"BOOLEAN":return"boolean";default:return"string"}}function Se(t,e){return e==="COLOR"&&typeof t=="object"&&"r"in t?fe(t):e==="FLOAT"&&typeof t=="number"||e==="BOOLEAN"&&typeof t=="boolean"||e==="STRING"&&typeof t=="string"?t:String(t)}function ke(t,e,o){const s=e.split("/");let r=t;for(let n=0;n<s.length-1;n++){const i=s[n];r[i]||(r[i]={}),r=r[i]}const a=s[s.length-1];r[a]=o}function ve(t){return t.toLowerCase().replace(/\s+/g,"-")}async function Ee(t={}){const e={success:!0,tokens:{},variablesProcessed:0,collectionsProcessed:0,errors:[],warnings:[]};try{const o=await ae();if(o.length===0)return e.warnings.push("No variable collections found in this file"),e;for(const s of o)if(!(t.collectionsToInclude&&!t.collectionsToInclude.includes(s.name)))try{const r=await figma.variables.getVariableCollectionByIdAsync(s.id);if(!r){e.errors.push(`Collection ${s.name} not found`);continue}const a=await z(r);if(a.length===0){e.warnings.push(`Collection ${s.name} has no variables`);continue}const n=ve(s.name),i={[n]:{}};for(const c of a)try{const l=r.defaultModeId,d=c.valuesByMode[l];if(d===void 0){e.warnings.push(`Variable ${c.name} has no value for default mode`);continue}const u=Ce(c.resolvedType),m={value:Se(d,c.resolvedType),type:u};c.description&&(m.comment=c.description);const p=`${n}/${c.name}`;ke(i,p,m),e.variablesProcessed++}catch(l){e.errors.push(`Failed to process variable ${c.name}: ${l instanceof Error?l.message:"Unknown error"}`)}t.organizeByCollection?e.tokens[`${n}.json`]=i:(e.tokens["tokens.json"]||(e.tokens["tokens.json"]={}),Object.assign(e.tokens["tokens.json"],i)),e.collectionsProcessed++}catch(r){e.errors.push(`Failed to process collection ${s.name}: ${r instanceof Error?r.message:"Unknown error"}`)}e.success=e.errors.length===0}catch(o){e.success=!1,e.errors.push(`Transform failed: ${o instanceof Error?o.message:"Unknown error"}`)}return e}function Te(t){return JSON.stringify(t,null,2)}function Ne(t,e){const o={added:[],modified:[],removed:[]},s=(n,i="")=>{const c=new Map;for(const[l,d]of Object.entries(n)){const u=i?`${i}.${l}`:l;d&&typeof d=="object"&&"value"in d?c.set(u,d):d&&typeof d=="object"&&s(d,u).forEach((m,p)=>c.set(p,m))}return c},r=s(t),a=s(e);return a.forEach((n,i)=>{if(!r.has(i))o.added.push(i);else{const c=r.get(i);JSON.stringify(c)!==JSON.stringify(n)&&o.modified.push(i)}}),r.forEach((n,i)=>{a.has(i)||o.removed.push(i)}),o}async function Oe(t,e){const o=t.getConfig();try{const r=(await ne(t,e.baseBranch)).object.sha,n=`figma-tokens-${Date.now()}`;await re(t,n,r),console.log(`Created branch: ${n}`);for(const c of e.files)try{let l="";try{l=(await t.request(`/repos/${o.owner}/${o.repo}/contents/${c.path}?ref=${e.baseBranch}`)).sha}catch(d){console.log(`File ${c.path} doesn't exist, will create new`)}await se(t,{path:c.path,content:c.content,message:`Update ${c.path} from Figma`,sha:l,branch:n}),console.log(`Updated ${c.path} on branch ${n}`)}catch(l){throw console.error(`Failed to update ${c.path}:`,l),new Error(`Failed to update ${c.path}: ${l instanceof Error?l.message:"Unknown error"}`)}const i=await t.request(`/repos/${o.owner}/${o.repo}/pulls`,{method:"POST",body:JSON.stringify({title:e.title,body:e.body,head:n,base:e.baseBranch})});return{success:!0,prUrl:i.html_url,prNumber:i.number,message:`Pull request created: ${i.html_url}`}}catch(s){return console.error("Failed to create PR:",s),{success:!1,message:`Failed to create pull request: ${s instanceof Error?s.message:"Unknown error"}`}}}function Re(t){if(t.added.length+t.modified.length+t.removed.length===0)return"Update design tokens from Figma";const o=[];return t.added.length>0&&o.push(`${t.added.length} added`),t.modified.length>0&&o.push(`${t.modified.length} modified`),t.removed.length>0&&o.push(`${t.removed.length} removed`),`Update design tokens from Figma (${o.join(", ")})`}function Fe(t,e){const o=[];return o.push("## Summary"),o.push(""),o.push("This PR updates design tokens exported from Figma variables."),o.push(""),o.push(`- **Collections processed:** ${e.collectionsProcessed}`),o.push(`- **Variables processed:** ${e.variablesProcessed}`),o.push(""),t.added.length>0||t.modified.length>0||t.removed.length>0?(o.push("## Changes"),o.push(""),t.added.length>0&&(o.push(`### âœ¨ Added (${t.added.length})`),o.push(""),t.added.slice(0,20).forEach(r=>{o.push(`- \`${r}\``)}),t.added.length>20&&o.push(`- ... and ${t.added.length-20} more`),o.push("")),t.modified.length>0&&(o.push(`### ðŸ”„ Modified (${t.modified.length})`),o.push(""),t.modified.slice(0,20).forEach(r=>{o.push(`- \`${r}\``)}),t.modified.length>20&&o.push(`- ... and ${t.modified.length-20} more`),o.push("")),t.removed.length>0&&(o.push(`### âŒ Removed (${t.removed.length})`),o.push(""),t.removed.slice(0,20).forEach(r=>{o.push(`- \`${r}\``)}),t.removed.length>20&&o.push(`- ... and ${t.removed.length-20} more`),o.push(""))):(o.push("## Changes"),o.push(""),o.push("No token changes detected (formatting or structure updates only)."),o.push("")),o.push("---"),o.push(""),o.push("ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)"),o.push(""),o.push("**Note:** Please review the changes carefully before merging."),o.join(`
`)}console.log("ðŸš€ Plugin loading - Figma Token Sync Plugin Started!"),console.log("ðŸš€ Build timestamp:",new Date().toISOString()),figma.showUI(__html__,{width:400,height:600,themeColors:!0}),console.log("ðŸš€ UI shown"),figma.ui.onmessage=async t=>{console.log("Plugin received message:",t.type);try{switch(t.type){case"INIT":{const e=await $();h({type:"SETTINGS_LOADED",settings:e});break}case"SAVE_SETTINGS":{const e=await C(t.settings);h({type:"SETTINGS_SAVED",success:e});break}case"TEST_CONNECTION":{console.log("Plugin received TEST_CONNECTION with config:",t.config),h({type:"SYNC_PROGRESS",message:"Testing connection..."});const e=await Pe(t.config);console.log("Test connection result:",e),h({type:"CONNECTION_TESTED",success:e.success,message:e.message});break}case"PULL_FROM_GITHUB":{h({type:"SYNC_STARTED",direction:"pull"});try{const e=await _e(t.config);if(e.success){const o=await $(),s=M(R({},o),{lastSync:{timestamp:Date.now(),direction:"pull",status:"success",message:e.message}});await C(s)}h({type:"SYNC_COMPLETE",success:e.success,message:e.message})}catch(e){const o=e instanceof Error?e.message:"Pull failed";h({type:"SYNC_COMPLETE",success:!1,message:o})}break}case"PUSH_TO_GITHUB":{h({type:"SYNC_STARTED",direction:"push"});try{const e=await Ae(t.config);if(e.success){const o=await $(),s=M(R({},o),{lastSync:{timestamp:Date.now(),direction:"push",status:"success",message:e.message}});await C(s)}h({type:"SYNC_COMPLETE",success:e.success,message:e.message,prUrl:e.prUrl})}catch(e){const o=e instanceof Error?e.message:"Push failed";h({type:"SYNC_COMPLETE",success:!1,message:o})}break}case"GET_COLLECTION_MODES":{try{const e=await ie(t.collectionName);h({type:"COLLECTION_MODES",modes:e})}catch(e){console.error("Failed to get collection modes:",e),h({type:"COLLECTION_MODES",modes:[]})}break}case"START_OAUTH_FLOW":{try{h({type:"SYNC_PROGRESS",message:"Starting OAuth flow..."});const e=await F.startDeviceFlow();h({type:"OAUTH_DEVICE_CODE",userCode:e.user_code,verificationUri:e.verification_uri,interval:e.interval,deviceCode:e.device_code})}catch(e){const o=e instanceof Error?e.message:"Failed to start OAuth flow";h({type:"OAUTH_ERROR",message:o})}break}case"POLL_OAUTH_TOKEN":{try{const e=await F.pollForToken(t.deviceCode,t.interval);h({type:"OAUTH_SUCCESS",token:e})}catch(e){const o=e instanceof Error?e.message:"OAuth authentication failed";h({type:"OAUTH_ERROR",message:o})}break}default:console.warn("Unknown message type:",t.type)}}catch(e){console.error("Error handling message:",e);let o="Unknown error occurred";e instanceof v?(o=`GitHub API Error: ${e.message}`,e.status&&(o+=` (Status: ${e.status})`)):e instanceof Error&&(o=e.message),h({type:"ERROR",message:o})}};function h(t){figma.ui.postMessage(t)}async function Pe(t){try{if(!t.token&&!t.oauthToken)return{success:!1,message:"No authentication token provided. Please authenticate with GitHub first."};if(!t.owner||!t.repo)return{success:!1,message:"Repository owner and name are required."};const e=new j(t);h({type:"SYNC_PROGRESS",message:"Verifying credentials..."});const o=await e.testConnection();if(!o.success)return o;if(t.tokenPaths&&t.tokenPaths.length>0){h({type:"SYNC_PROGRESS",message:"Exploring repository structure..."});try{console.log("ðŸ” Attempting to list root directory...");const c=await e.request(`/repos/${t.owner}/${t.repo}/contents?ref=${t.branch||"main"}`);console.log("ðŸ—‚ï¸ Raw root response type:",typeof c,Array.isArray(c)),console.log("ðŸ—‚ï¸ Raw root response sample:",c[0]||c);const l=Array.isArray(c)?c:[c];console.log("ðŸ—‚ï¸ Repository root contents:",l.map(d=>`${d.name||d.filename||"unknown"} (${d.type||"unknown"})`)),h({type:"SYNC_PROGRESS",message:`Repository has ${l.length} items in root: ${l.slice(0,5).map(d=>d.name).join(", ")}${l.length>5?"...":""}`})}catch(c){console.error("Failed to list root directory:",c),h({type:"SYNC_PROGRESS",message:"Could not explore repository structure (continuing...)"})}h({type:"SYNC_PROGRESS",message:"Searching for token files..."});const r=await H(e,t.tokenPaths,t.branch);if(r.length===0)return{success:!1,message:`No token files found matching patterns: ${t.tokenPaths.join(", ")}`};const n=(await e.validateTokenPaths(r)).results.filter(c=>!c.exists);if(n.length>0)return{success:!1,message:`Missing token files: ${n.map(c=>c.path).join(", ")}`};const i=o.details;return{success:!0,message:`âœ“ Connected as ${i.user} to ${i.repo} (${i.branch})
âœ“ Found ${r.length} token file(s)
âœ“ Write access: ${i.hasWriteAccess?"Yes":"No"}`}}const s=o.details;return{success:!0,message:`âœ“ Connected as ${s.user} to ${s.repo} (${s.branch})
âœ“ Write access: ${s.hasWriteAccess?"Yes":"No"}`}}catch(e){return e instanceof v?{success:!1,message:e.message}:{success:!1,message:e instanceof Error?e.message:"Connection test failed"}}}async function _e(t){try{const e=new j(t);h({type:"SYNC_PROGRESS",message:"Finding token files..."});const o=await H(e,t.tokenPaths,t.branch);if(o.length===0)return{success:!1,message:`No token files found matching patterns: ${t.tokenPaths.join(", ")}`};h({type:"SYNC_PROGRESS",message:`Found ${o.length} token file(s)`}),h({type:"SYNC_PROGRESS",message:"Fetching token files..."});const s=await x(e,o,t.branch),r=s.filter(p=>p.error);if(r.length>0)return{success:!1,message:`Failed to fetch files:
${r.map(p=>`- ${p.path}: ${p.error}`).join(`
`)}`};h({type:"SYNC_PROGRESS",message:"Analyzing token structure..."});const a=ge(o),n=he(a);console.log(`ðŸ¢ Multi-brand structure detected: ${n}`),n&&console.log(`ðŸ·ï¸ Brands found: ${P(a).join(", ")}`),h({type:"SYNC_PROGRESS",message:"Parsing token files..."});const i=pe(s,a);if(i.length===0)return{success:!1,message:"No valid token files found to process"};h({type:"SYNC_PROGRESS",message:"Creating Figma variables..."});let c=0,l=0,d=0;const u=[],f=[];try{if(n){h({type:"SYNC_PROGRESS",message:"Processing multi-brand tokens..."});const p={collectionName:t.targetCollection||void 0,targetMode:t.targetMode||void 0};console.log("ðŸŽ¯ Multi-brand transform options:",p);const b=await $e(i,a,p);c+=b.collectionsCreated,l+=b.variablesCreated,d+=b.variablesUpdated,u.push(...b.errors),f.push(...b.warnings),b.success||console.error("Failed to transform multi-brand tokens:",b.errors)}else{h({type:"SYNC_PROGRESS",message:"Processing single-brand tokens..."});const p={};for(const w of i)Object.assign(p,w.tokens),console.log(`ðŸ“¦ Merged tokens from ${w.path}`);const b=O(p);console.log(`ðŸ”— Resolved ${Object.keys(p).length} top-level token groups`);const y={collectionName:t.targetCollection||void 0,targetMode:t.targetMode||void 0};console.log("ðŸŽ¯ Single-brand transform options:",y);const g=await be(b,y);c+=g.collectionsCreated,l+=g.variablesCreated,d+=g.variablesUpdated,u.push(...g.errors),f.push(...g.warnings),g.success||console.error("Failed to transform tokens:",g.errors)}}catch(p){const b=`Failed to process tokens: ${p instanceof Error?p.message:"Unknown error"}`;u.push(b),console.error(b)}if(u.length>0)return{success:!1,message:`Sync completed with errors:
${u.slice(0,5).join(`
`)}${u.length>5?`
... and ${u.length-5} more errors`:""}`};const m=[`âœ“ Successfully imported ${s.length} token file(s)`,n?`âœ“ Multi-brand structure with ${P(a).length} brands: ${P(a).join(", ")}`:"âœ“ Single-brand structure",`âœ“ Collections: ${c} created`,`âœ“ Variables: ${l} created, ${d} updated`];return n&&m.push(`âœ“ Modes created: Default + ${P(a).join(", ")}`),f.length>0&&m.push(`âš  Warnings: ${f.length}`),{success:!0,message:m.join(`
`)}}catch(e){return console.error("Pull failed:",e),e instanceof v?{success:!1,message:`GitHub API Error: ${e.message}`}:{success:!1,message:e instanceof Error?e.message:"Pull failed"}}}async function Ae(t){try{const e=new j(t);h({type:"SYNC_PROGRESS",message:"Reading Figma variables..."});const o=await Ee({organizeByCollection:!0});if(!o.success)return{success:!1,message:`Failed to read variables:
${o.errors.join(`
`)}`};if(o.variablesProcessed===0)return{success:!1,message:"No variables found in this file. Create some variables first!"};h({type:"SYNC_PROGRESS",message:`Read ${o.variablesProcessed} variables from ${o.collectionsProcessed} collection(s)`}),h({type:"SYNC_PROGRESS",message:"Preparing token files..."});const s=[];for(const[l,d]of Object.entries(o.tokens)){let u;if(t.tokenPaths.length===1&&!t.tokenPaths[0].includes("*"))u=t.tokenPaths[0];else{const m=t.tokenPaths[0]||"tokens/**/*.json";let p="tokens";if(m.includes("/")){const b=m.split("/"),y=b.filter(g=>!g.includes("*"));y.length>0?p=y.join("/"):p=b[0]==="."?"tokens":b[0]}u=`${p}/${l}`}console.log(`ðŸ“ Generated file path: ${u} for collection file: ${l}`);const f=Te(d);s.push({path:u,content:f})}h({type:"SYNC_PROGRESS",message:"Generating changelog..."});let r={added:[],modified:[],removed:[]};for(const l of s)try{const d=await x(e,[l.path],t.branch);if(d[0]&&!d[0].error){const u=we(d[0].content),f=JSON.parse(l.content),m=Ne(u,f);r.added.push(...m.added),r.modified.push(...m.modified),r.removed.push(...m.removed)}else{const u=JSON.parse(l.content),f=p=>{let b=0;for(const y of Object.values(p))y&&typeof y=="object"&&"value"in y?b++:y&&typeof y=="object"&&(b+=f(y));return b},m=f(u);r.added.push(`${l.path} (${m} tokens)`)}}catch(d){console.warn(`Could not fetch ${l.path} for comparison:`,d)}h({type:"SYNC_PROGRESS",message:"Creating Pull Request..."});const a=Re(r),n=Fe(r,{collectionsProcessed:o.collectionsProcessed,variablesProcessed:o.variablesProcessed}),i=await Oe(e,{title:a,body:n,baseBranch:t.branch||"main",files:s});return i.success?{success:!0,message:["âœ“ Successfully created Pull Request",`âœ“ Files: ${s.length} updated`,`âœ“ Variables: ${o.variablesProcessed} exported`,`âœ“ PR: ${i.prUrl}`].join(`
`),prUrl:i.prUrl}:{success:!1,message:i.message}}catch(e){return console.error("Push failed:",e),e instanceof v?{success:!1,message:`GitHub API Error: ${e.message}`}:{success:!1,message:e instanceof Error?e.message:"Push failed"}}}})();
